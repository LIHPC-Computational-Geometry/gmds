/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/** \file    VTKWriter.h
 *  \author  F. LEDOUX
 *  \date    02/24/2009
 */
/*----------------------------------------------------------------------------*/
#ifndef KMDS_VTKWRITER_H_
#define KMDS_VTKWRITER_H_
/*----------------------------------------------------------------------------*/
// headers of STL files
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
/*----------------------------------------------------------------------------*/
// headers of GMDS files
#include <gmds/ig/Mesh.h>
//#include <GMDS/IG/IG.h>
//#include <GMDS/Math/Quaternion.h>
//#include <GMDS/Math/Cross.h>
//#include <GMDS/Math/Cross2D.h>

#include <KM/DS/Mesh.h>
/*----------------------------------------------------------------------------*/
namespace kmds{
    /*----------------------------------------------------------------------------*/
#include <KM/IO/VTKWriter_def.h>
    
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    VTKWriter<TMesh>::VTKWriter(TMesh& AMesh)
    :mesh_(AMesh)
    {

    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    VTKWriter<TMesh>::~VTKWriter()
    {
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::
    write(const std::string& AFileName, const int& AMask)
    {
        
        if ((AMask | F) == AMask)
            writeFaces(AFileName);
        
        if ((AMask | R) == AMask)
            writeRegions(AFileName);
        
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::
    writeFaces(const std::string& AFileName)
    {
        
        std::stringstream file_name;
        file_name << AFileName << "_FACES.vtk";
        std::ofstream output(file_name.str(), std::ios::out);
        if (!output)
            throw KException("Impossible to create a VTK File (Legacy format)");
        
        output << "# vtk DataFile Version 3.0\n";
        output << "Generated by KMDS VTK Writer\n\n";
        output << "ASCII\n";
        output << "DATASET UNSTRUCTURED_GRID\n";
        
        writeNodes(output);
        
        writeCellFaces(output);
        
        writeNodesData(output);
        writeFacesData(output);
        output.close();
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeRegions(const std::string& AFileName)
    {
        
        std::stringstream file_name;
        file_name << AFileName << "_CELLS.vtk";
        std::ofstream output(file_name.str(), std::ios::out);
        if (!output)
            throw KException("Impossible to create a VTK File (Legacy format)");
        
        output << "# vtk DataFile Version 3.0\n";
        output << "Generated by KMDS VTK Writer\n\n";
        output << "ASCII\n";
        output << "DATASET UNSTRUCTURED_GRID\n";
        
        writeNodes(output);
        
        writeCellRegions(output);
        
        writeNodesData(output);
        writeRegionsData(output);
        output.close();
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeNodes(std::ofstream& AOut)
    {
        TSize nbNodes = mesh_.getNbNodes();
        AOut << "POINTS " << nbNodes << " float\n";
        kmds::GrowingView<kmds::TCellID> nodeIDs("NODES", nbNodes);
        mesh_.getNodeIDsSeq(&nodeIDs);

        int vtk_node_id = 0;

        for(int i=0; i<nbNodes; i++) {
            TCellID nid = nodeIDs.get(i);
            Node n = mesh_.getNode(nid);

            TCoord coords[3];
            n.getLocation(coords[0], coords[1], coords[2]);
            AOut << coords[0] << " " << coords[1] << " " << coords[2] << "\n";
            nodes_connection_[nid] = vtk_node_id++;
        }

    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeCellFaces(std::ofstream& AOut)
    {
        AOut << "CELLS ";
        int nb_cells = mesh_.getNbFaces();
        AOut << nb_cells << " ";

        kmds::GrowingView<kmds::TCellID> cellIDs("CELLS", nb_cells);
        mesh_.getFaceIDsSeq(&cellIDs);

        int vtk_cell_size = 0;

        for(int i=0; i<nb_cells; i++) {
            Face c = mesh_.getFace(cellIDs.get(i));

            vtk_cell_size += 1 + c.getNbNodes();
        }

        AOut << vtk_cell_size << "\n";
        
        int vtk_cell_id = 0;

        for(int i=0; i<nb_cells; i++) {
            TCellID cid = cellIDs.get(i);
            Face c = mesh_.getFace(cid);

            Kokkos::View<kmds::TCellID *> ids;
            c.nodeIds(ids);

            AOut << ids.size() << " ";
            for (unsigned int i_n = 0; i_n < ids.size(); i_n++){
                AOut << nodes_connection_[ids[i_n]] << " ";
            }
            AOut << "\n";
            faces_connection_[cid] = vtk_cell_id++;
        }

        AOut << "CELL_TYPES " << nb_cells << "\n";

        for(int i=0; i<nb_cells; i++) {
            TCellID cid = cellIDs.get(i);

            Face c = mesh_.getFace(cid);

            switch(c.computeType()) {
                case KMDS_TRIANGLE :
                    AOut << "5 \n";
                    break;
                case KMDS_QUAD :
                    AOut << "9 \n";
                    break;
                default:
                    AOut << "7 \n";
                    break;
            }
        }
        
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeCellRegions(std::ofstream& AOut)
    {
        AOut << "CELLS ";
        int nb_cells = mesh_.getNbRegions();
        AOut << nb_cells << " ";

        kmds::GrowingView<kmds::TCellID> cellIDs("CELLS", nb_cells);
        mesh_.getRegionIDsSeq(&cellIDs);

        int vtk_cell_size = 0;

        for(int i=0; i<nb_cells; i++) {
            Region c = mesh_.getRegion(cellIDs.get(i));

            vtk_cell_size += 1 + c.getNbNodes();
        }

        AOut << vtk_cell_size << "\n";

        int vtk_cell_id = 0;

        for(int i=0; i<nb_cells; i++) {
            TCellID cid = cellIDs.get(i);
            Region c = mesh_.getRegion(cid);

            Kokkos::View<kmds::TCellID *> ids;
            c.nodeIds(ids);

            AOut << ids.size() << " ";
            for (unsigned int i_n = 0; i_n < ids.size(); i_n++){
                AOut << nodes_connection_[ids[i_n]] << " ";
            }
            AOut << "\n";
            regions_connection_[cid] = vtk_cell_id++;
        }

        AOut << "CELL_TYPES " << nb_cells << "\n";

        for(int i=0; i<nb_cells; i++) {
            TCellID cid = cellIDs.get(i);

            Region c = mesh_.getRegion(cid);

            switch(c.computeType()) {
                case KMDS_TETRA :
                    AOut << "10 \n";
                    break;
                case KMDS_HEX :
                    AOut << "12 \n";
                    break;
                case KMDS_PRISM3 :
                    AOut << "13 \n";
                    break;
                case KMDS_PYRAMID :
                    AOut << "14 \n";
                    break;
                default:
                    throw KException("VTKWriter::writeCellRegions cell type not handled.");
                    break;
            }
        }

    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeNodesData(std::ofstream& AOut)
    {
        TSize nbNodes = mesh_.getNbNodes();

        AOut << "POINT_DATA " << nbNodes << "\n";
        
        /* FIRST WE PUT THE KMDS IDS*/
        AOut << "SCALARS KMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";

        kmds::GrowingView<kmds::TCellID> nodeIDs("NODES", nbNodes);
        mesh_.getNodeIDsSeq(&nodeIDs);

        for(int i=0; i<nbNodes; i++) {
            TCellID nid = nodeIDs.get(i);

            AOut << nid << "\n";
        }

        /* THEN WE LOOK AT THE VARIABLES*/
        std::vector<VariableItf*> node_variables = mesh_.getVariableManager(KMDS_NODE)->getAllVariables();
        for (int i = 0; i < node_variables.size(); i++)
        {
            VariableItf* current_var = node_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);
                    
                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int inode=0; inode<nbNodes; inode++) {
                        AOut << (*v_int)[nodeIDs.get(inode)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int inode=0; inode<nbNodes; inode++) {
                        AOut << (*v_double)[nodeIDs.get(inode)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<gmds::math::Vector>* var_double_vec3D =
                    dynamic_cast<Variable<gmds::math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";

                    for(int inode=0; inode<nbNodes; inode++) {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[nodeIDs.get(inode)].X();
                        tuple[1] = (*var_double_vec3D)[nodeIDs.get(inode)].Y();
                        tuple[2] = (*var_double_vec3D)[nodeIDs.get(inode)].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                default:
                    break;
            }
        }
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeFacesData(std::ofstream& AOut)
    {
        TSize nbCells = mesh_.getNbFaces();

        AOut << "CELL_DATA " << nbCells << "\n";

        /* FIRST WE PUT THE KMDS IDS*/
        AOut << "SCALARS KMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";

        kmds::GrowingView<kmds::TCellID> cellIDs("CELLS", nbCells);
        mesh_.getFaceIDsSeq(&cellIDs);

        for(int i=0; i<nbCells; i++) {
            TCellID cid = cellIDs.get(i);

            AOut << cid << "\n";
        }

        /* THEN WE LOOK AT THE VARIABLES*/
        std::vector<VariableItf*> cell_variables = mesh_.getVariableManager(KMDS_FACE)->getAllVariables();
        for (int i = 0; i < cell_variables.size(); i++)
        {
            VariableItf* current_var = cell_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);

                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int icell=0; icell<nbCells; icell++) {
                        AOut << (*v_int)[cellIDs.get(icell)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int icell=0; icell<nbCells; icell++) {
                        AOut << (*v_double)[cellIDs.get(icell)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<gmds::math::Vector>* var_double_vec3D =
                            dynamic_cast<Variable<gmds::math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";

                    for(int icell=0; icell<nbCells; icell++) {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[cellIDs.get(icell)].X();
                        tuple[1] = (*var_double_vec3D)[cellIDs.get(icell)].Y();
                        tuple[2] = (*var_double_vec3D)[cellIDs.get(icell)].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                default:
                    break;
            }
        }
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeRegionsData(std::ofstream& AOut)
    {
        TSize nbCells = mesh_.getNbRegions();

        AOut << "CELL_DATA " << nbCells << "\n";

        /* FIRST WE PUT THE KMDS IDS*/
        AOut << "SCALARS KMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";

        kmds::GrowingView<kmds::TCellID> cellIDs("CELLS", nbCells);
        mesh_.getRegionIDsSeq(&cellIDs);

        for(int i=0; i<nbCells; i++) {
            TCellID cid = cellIDs.get(i);

            AOut << cid << "\n";
        }

        /* THEN WE LOOK AT THE VARIABLES*/
        std::vector<VariableItf*> cell_variables = mesh_.getVariableManager(KMDS_REGION)->getAllVariables();
        for (int i = 0; i < cell_variables.size(); i++)
        {
            VariableItf* current_var = cell_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);

                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int icell=0; icell<nbCells; icell++) {
                        AOut << (*v_int)[cellIDs.get(icell)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";

                    for(int icell=0; icell<nbCells; icell++) {
                        AOut << (*v_double)[cellIDs.get(icell)] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<gmds::math::Vector>* var_double_vec3D =
                            dynamic_cast<Variable<gmds::math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";

                    for(int icell=0; icell<nbCells; icell++) {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[cellIDs.get(icell)].X();
                        tuple[1] = (*var_double_vec3D)[cellIDs.get(icell)].Y();
                        tuple[2] = (*var_double_vec3D)[cellIDs.get(icell)].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                default:
                    break;
            }
        }
    }
    /*----------------------------------------------------------------------------*/
//    template<typename TMesh>
//    void VTKWriter<TMesh>::writeVectorSection(
//                                              std::ofstream& AOut,
//                                              const std::vector<math::Vector>& AV)
//    {
//        for (unsigned int i = 0; i < AV.size() ; i++)
//        {
//            math::Vector v = AV[i];
//            AOut << v.X() << " " << v.Y() << " " << v.Z() << "\n";
//        }
//
//    }
  /*----------------------------------------------------------------------------*/
}
/*----------------------------------------------------------------------------*/
#endif /* KMDS_VTKWRITER_H_ */
/*----------------------------------------------------------------------------*/
