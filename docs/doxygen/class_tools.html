<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gmds: Tools Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gmds
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_tools-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tools Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tools_1_1_point_surfacic_data.html">PointSurfacicData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tools_1_1_point_volumetric_data.html">PointVolumetricData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada0b605250ac1486bd3698730c63f2de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ada0b605250ac1486bd3698730c63f2de">Tools</a> (<a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *AMesh, <a class="el" href="classgmds_1_1_variable.html">gmds::Variable</a>&lt; <a class="el" href="classgmds_1_1math_1_1_cross2_d.html">gmds::math::Cross2D</a> &gt; *AField, <a class="el" href="classgmds_1_1_variable.html">gmds::Variable</a>&lt; <a class="el" href="classgmds_1_1math_1_1_axis_angle_rotation.html">gmds::math::AxisAngleRotation</a> &gt; *ARotField=0)</td></tr>
<tr class="memdesc:ada0b605250ac1486bd3698730c63f2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_tools.html#ada0b605250ac1486bd3698730c63f2de">More...</a><br /></td></tr>
<tr class="separator:ada0b605250ac1486bd3698730c63f2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787551b6cbd4c1f2f91fe8d053dca50e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a787551b6cbd4c1f2f91fe8d053dca50e">followFlow</a> (const <a class="el" href="struct_tools_1_1_point_volumetric_data.html">PointVolumetricData</a> &amp;AData, const double AMaxDist, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt)</td></tr>
<tr class="memdesc:a787551b6cbd4c1f2f91fe8d053dca50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute where the frame field defined by m_axis_angle will transport <code>AData.pnt</code> considering data in <code>AData</code> and the max distance is <code>AMaxDist</code>.  <a href="class_tools.html#a787551b6cbd4c1f2f91fe8d053dca50e">More...</a><br /></td></tr>
<tr class="separator:a787551b6cbd4c1f2f91fe8d053dca50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704bea512e492845e8671fa019598edf"><td class="memItemLeft" align="right" valign="top"><a id="a704bea512e492845e8671fa019598edf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>followFlow</b> (const <a class="el" href="struct_tools_1_1_point_surfacic_data.html">PointSurfacicData</a> &amp;AData, const double AMaxDist, const int AMarkEdgeOnCurve, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt)</td></tr>
<tr class="separator:a704bea512e492845e8671fa019598edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cf4ba27d13faf756f957bb508d4599"><td class="memItemLeft" align="right" valign="top"><a id="af1cf4ba27d13faf756f957bb508d4599"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFFSingular</b> (const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AR)</td></tr>
<tr class="separator:af1cf4ba27d13faf756f957bb508d4599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa442595e4d4aae9daafb22f837eb8749"><td class="memItemLeft" align="right" valign="top"><a id="aa442595e4d4aae9daafb22f837eb8749"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFFSingular</b> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AF)</td></tr>
<tr class="separator:aa442595e4d4aae9daafb22f837eb8749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62b727e7241e264b958d2729bb32998"><td class="memItemLeft" align="right" valign="top"><a id="ab62b727e7241e264b958d2729bb32998"></a>
<a class="el" href="classgmds_1_1math_1_1_chart_1_1_mapping.html">gmds::math::Chart::Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRij</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> AFrom, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ATo) const</td></tr>
<tr class="separator:ab62b727e7241e264b958d2729bb32998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba6f52deed9997e1a0890b0b9fe0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a1fba6f52deed9997e1a0890b0b9fe0d2">traverseTriangle</a> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace, const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, const int AInCellDIm, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> AInCellID, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, int &amp;AOutCellDIm, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AOutCellID, double &amp;streamlineDeviation)</td></tr>
<tr class="memdesc:a1fba6f52deed9997e1a0890b0b9fe0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the out point when we go through a triangle following the cross field.  <a href="class_tools.html#a1fba6f52deed9997e1a0890b0b9fe0d2">More...</a><br /></td></tr>
<tr class="separator:a1fba6f52deed9997e1a0890b0b9fe0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890fcfeb7ece1f554d208c0da8cfa061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a890fcfeb7ece1f554d208c0da8cfa061">traverseTriangle</a> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;ANode, const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, int &amp;AOutCellDIm, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AOutCellID, double &amp;streamlineDeviation)</td></tr>
<tr class="memdesc:a890fcfeb7ece1f554d208c0da8cfa061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the out point when we go through a triangle following the cross field and starting from a node.  <a href="class_tools.html#a890fcfeb7ece1f554d208c0da8cfa061">More...</a><br /></td></tr>
<tr class="separator:a890fcfeb7ece1f554d208c0da8cfa061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6342c91c1d06ba72ac88fc9d0442cac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a6342c91c1d06ba72ac88fc9d0442cac7">traverseTriangle</a> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AEdge, const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, int &amp;AOutCellDIm, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AOutCellID, double &amp;streamlineDeviation)</td></tr>
<tr class="memdesc:a6342c91c1d06ba72ac88fc9d0442cac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the out point when we go through a triangle following the cross field and starting from an edge.  <a href="class_tools.html#a6342c91c1d06ba72ac88fc9d0442cac7">More...</a><br /></td></tr>
<tr class="separator:a6342c91c1d06ba72ac88fc9d0442cac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a83c3184f53a7e2bf31f472828ace4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ac7a83c3184f53a7e2bf31f472828ace4">heunsComputation</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AOppNode, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AInNode1, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AInNode2, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AOutEdge1, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AOutEdge2, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, double &amp;deviation)</td></tr>
<tr class="memdesc:ac7a83c3184f53a7e2bf31f472828ace4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Heun's algorithm into a triangle to compute the out point when we go through this triangle and we arrive from an edge. Note that the algorithm is numerically corrected to avoid to go back in the face we come from.  <a href="class_tools.html#ac7a83c3184f53a7e2bf31f472828ace4">More...</a><br /></td></tr>
<tr class="separator:ac7a83c3184f53a7e2bf31f472828ace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7856231d1e36890d39fb9cd5ddc0573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ac7856231d1e36890d39fb9cd5ddc0573">heunsComputation</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AOppNode1, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AOppNode2, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AOppEdge, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, double &amp;deviation)</td></tr>
<tr class="memdesc:ac7856231d1e36890d39fb9cd5ddc0573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Heun's algorithm into a triangle to compute the out point when we go through this triangle and we arrive from a node. Note that the algorithm is numerically corrected to avoid to go out from the triangle we get in.  <a href="class_tools.html#ac7856231d1e36890d39fb9cd5ddc0573">More...</a><br /></td></tr>
<tr class="separator:ac7856231d1e36890d39fb9cd5ddc0573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a577ffce8d9d01df14679e4d37538d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a3a577ffce8d9d01df14679e4d37538d7">RK4Computation</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AINPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AINVec, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOUTPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOUTVec, double &amp;deviation, const double &amp;stepSize, bool &amp;AEndOnBdry, std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;ATriangles, int &amp;AToCellDim, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AToCellID)</td></tr>
<tr class="memdesc:a3a577ffce8d9d01df14679e4d37538d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Runge-Kutta algorithm into a triangle to compute the out point when we go through this triangle and we arrive from an edge. Note that the algorithm is numerically corrected to avoid to go back in the face we come from.  <a href="class_tools.html#a3a577ffce8d9d01df14679e4d37538d7">More...</a><br /></td></tr>
<tr class="separator:a3a577ffce8d9d01df14679e4d37538d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf3a24674d7ecd0cca2bb180ed06353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a9cf3a24674d7ecd0cca2bb180ed06353">computeOutVectorFromRayAndEdge</a> (const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AEdge, const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AInPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AOutPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec, double &amp;deviation)</td></tr>
<tr class="memdesc:a9cf3a24674d7ecd0cca2bb180ed06353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let a ray r=[AInPnt, AInVec) interesecting an edge AEdge, this method returns the point of intersection P between r and AEdge, and the output vector at P, that respects the underlying cross field.  <a href="class_tools.html#a9cf3a24674d7ecd0cca2bb180ed06353">More...</a><br /></td></tr>
<tr class="separator:a9cf3a24674d7ecd0cca2bb180ed06353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea4ace0eab94e42a2404a77b9528af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ae3ea4ace0eab94e42a2404a77b9528af">computeOutVectorAtPoint</a> (const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;ANode, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AInVec, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AOutVec)</td></tr>
<tr class="memdesc:ae3ea4ace0eab94e42a2404a77b9528af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arriving at node ANode with direction AInVec, it returns the best fit direction prescribed by the cross field at ANode.  <a href="class_tools.html#ae3ea4ace0eab94e42a2404a77b9528af">More...</a><br /></td></tr>
<tr class="separator:ae3ea4ace0eab94e42a2404a77b9528af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0eaf7692fc920e2bd10307183ff57d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a9c0eaf7692fc920e2bd10307183ff57d">findNextCell</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AFromVec, const int AFromCellDim, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> AFromCellID, int &amp;AToCellDim, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AToCellID)</td></tr>
<tr class="memdesc:a9c0eaf7692fc920e2bd10307183ff57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the next cell we will go through. It is a face (dim=2), or an edge (dim=1).  <a href="class_tools.html#a9c0eaf7692fc920e2bd10307183ff57d">More...</a><br /></td></tr>
<tr class="separator:a9c0eaf7692fc920e2bd10307183ff57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dcbb92c65644d3786fd6c384a49cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ab5dcbb92c65644d3786fd6c384a49cb8">findNextCell</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AFromVec, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AFromNode, int &amp;AToCellDim, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AToCellID)</td></tr>
<tr class="memdesc:ab5dcbb92c65644d3786fd6c384a49cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the next cell we will got through. It is a face (dim=2), or an edge (dim=1).  <a href="class_tools.html#ab5dcbb92c65644d3786fd6c384a49cb8">More...</a><br /></td></tr>
<tr class="separator:ab5dcbb92c65644d3786fd6c384a49cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d60ad11d5c251f5ae3c632f1f6b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a0a7d60ad11d5c251f5ae3c632f1f6b88">findNextCell</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AFromVec, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AFromEdge, int &amp;AToCellDim, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AToCellID)</td></tr>
<tr class="memdesc:a0a7d60ad11d5c251f5ae3c632f1f6b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the next cell we will got through. It is a face (dim=2), or an edge (dim=1).  <a href="class_tools.html#a0a7d60ad11d5c251f5ae3c632f1f6b88">More...</a><br /></td></tr>
<tr class="separator:a0a7d60ad11d5c251f5ae3c632f1f6b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006d70280bd2b56e1692c79014c07338"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a006d70280bd2b56e1692c79014c07338">isAlong</a> (const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AVec, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AFromNode, <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AEdge)</td></tr>
<tr class="memdesc:a006d70280bd2b56e1692c79014c07338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the ray starting from AFromNode and following AVec is aligned with AEdge.  <a href="class_tools.html#a006d70280bd2b56e1692c79014c07338">More...</a><br /></td></tr>
<tr class="separator:a006d70280bd2b56e1692c79014c07338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d696b02ff4c33dd03418920e8e5802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a26d696b02ff4c33dd03418920e8e5802">isGoingInto</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AVec, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;AFromNode, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace)</td></tr>
<tr class="memdesc:a26d696b02ff4c33dd03418920e8e5802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the ray starting from APnt and following AVec is going into the face AFace.  <a href="class_tools.html#a26d696b02ff4c33dd03418920e8e5802">More...</a><br /></td></tr>
<tr class="separator:a26d696b02ff4c33dd03418920e8e5802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad376f04fa751eb4bd6369a55ba1d5f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#ad376f04fa751eb4bd6369a55ba1d5f97">isGoingInto</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AVec, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AFromEdge, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace)</td></tr>
<tr class="memdesc:ad376f04fa751eb4bd6369a55ba1d5f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the ray starting from APnt and following AVec is going into the face AFace.  <a href="class_tools.html#ad376f04fa751eb4bd6369a55ba1d5f97">More...</a><br /></td></tr>
<tr class="separator:ad376f04fa751eb4bd6369a55ba1d5f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a5b0f9ca5a38b2fbaeb7a797e3ec64"><td class="memItemLeft" align="right" valign="top"><a id="ac9a5b0f9ca5a38b2fbaeb7a797e3ec64"></a>
<a class="el" href="classgmds_1_1math_1_1_chart.html">gmds::math::Chart</a>&#160;</td><td class="memItemRight" valign="bottom"><b>computeChartIn</b> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace)</td></tr>
<tr class="separator:ac9a5b0f9ca5a38b2fbaeb7a797e3ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594cd08b8aa630962c01acd068709465"><td class="memItemLeft" align="right" valign="top"><a id="a594cd08b8aa630962c01acd068709465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeFuzzyHeuns</b> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AFromDir, const std::vector&lt; <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &gt; &amp;AFaces, const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_triangle.html">gmds::math::Triangle</a> &gt; &amp;ATri, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AToPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AToDir, int &amp;AToFaceId)</td></tr>
<tr class="separator:a594cd08b8aa630962c01acd068709465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb80ed6329bb38870022a3dc05241bc"><td class="memItemLeft" align="right" valign="top"><a id="abcb80ed6329bb38870022a3dc05241bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeFuzzyHeuns</b> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;ADirPnt, const std::vector&lt; <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &gt; &amp;AFaces, const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_segment.html">gmds::math::Segment</a> &gt; &amp;ATri, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AToPnt, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AToDir, int &amp;AToFaceId)</td></tr>
<tr class="separator:abcb80ed6329bb38870022a3dc05241bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242e539d4ff1d2144929d585f545bbce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a242e539d4ff1d2144929d585f545bbce">isPntInTri</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;ATri, bool &amp;AOnEdge0, bool &amp;AOnEdge1, bool &amp;AOnEdge2, double &amp;lambda1, double &amp;lambda2)</td></tr>
<tr class="memdesc:a242e539d4ff1d2144929d585f545bbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a point <code>APnt</code> projected onto the plane defining <code>ATri</code> belong to <code>ATri</code> or not. Boolean <code>AOnEdge0</code>, <code>AOnEdge1</code> and <code><code>AOnEdge2</code> indicates</code> if the points lies on the edge o opposite to node 0, 1 and 3 respectively.  <a href="class_tools.html#a242e539d4ff1d2144929d585f545bbce">More...</a><br /></td></tr>
<tr class="separator:a242e539d4ff1d2144929d585f545bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd543d9dc0fa60be36f4a9e05edcbe1a"><td class="memItemLeft" align="right" valign="top"><a id="acd543d9dc0fa60be36f4a9e05edcbe1a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPntInTri</b> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;ATri)</td></tr>
<tr class="separator:acd543d9dc0fa60be36f4a9e05edcbe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d72075e5590992843fd044bf1af8ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a29d72075e5590992843fd044bf1af8ae">getNextVectorRK4</a> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace, vector&lt; double &gt; &amp;lambdas, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;v_in, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;v_next)</td></tr>
<tr class="memdesc:a29d72075e5590992843fd044bf1af8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the next RK4 vector at a <code>point_1</code> inside face <code>AFace</code> this function assumes we have already checked and <code>point_1</code> is in triangle <code>AFace</code>  <a href="class_tools.html#a29d72075e5590992843fd044bf1af8ae">More...</a><br /></td></tr>
<tr class="separator:a29d72075e5590992843fd044bf1af8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e6c255ffa3765b6c9a2e32f457ac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a626e6c255ffa3765b6c9a2e32f457ac0">findTriangleAndNextVectorRK4</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AINPnt, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;point_x, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;v_in, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;v_next, bool &amp;AEndOnBdry, std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;ATriangles, int &amp;AToCellDim, <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AToCellID, bool &amp;isFinal, vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;previousVisitedFaces)</td></tr>
<tr class="memdesc:a626e6c255ffa3765b6c9a2e32f457ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the next RK4 vector at a <code>point_1</code> knowing that we have started from face <code>AFace</code> in this function we only know in which triangle(<code>AFace</code>) our initial point was located; therefore we have to find in which triangle <code>point_1</code> is located  <a href="class_tools.html#a626e6c255ffa3765b6c9a2e32f457ac0">More...</a><br /></td></tr>
<tr class="separator:a626e6c255ffa3765b6c9a2e32f457ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a688103915c035157e32856271db7d0"><td class="memItemLeft" align="right" valign="top"><a id="a7a688103915c035157e32856271db7d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAdjacency</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AFace1, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AFace2)</td></tr>
<tr class="separator:a7a688103915c035157e32856271db7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ccc4418d372fb006ff976929bed1e7"><td class="memItemLeft" align="right" valign="top"><a id="aa8ccc4418d372fb006ff976929bed1e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAdjacency</b> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace1, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace2)</td></tr>
<tr class="separator:aa8ccc4418d372fb006ff976929bed1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c8854071658eff0adb198c8a9c59f70"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tools.html#a7c8854071658eff0adb198c8a9c59f70">removeBoundarySlivers</a> (<a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *AMesh)</td></tr>
<tr class="memdesc:a7c8854071658eff0adb198c8a9c59f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes boundary slivers for a mesh with R|N|R2N|N2R model.  <a href="class_tools.html#a7c8854071658eff0adb198c8a9c59f70">More...</a><br /></td></tr>
<tr class="separator:a7c8854071658eff0adb198c8a9c59f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a29cb99261b06bc04251b588ce8f1"><td class="memItemLeft" align="right" valign="top"><a id="a909a29cb99261b06bc04251b588ce8f1"></a>
static <a class="el" href="classgmds_1_1_node.html">gmds::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getOpposedNodeOnEdge</b> (const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;ANode, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;<a class="el" href="classgmds_1_1_edge.html">Edge</a>)</td></tr>
<tr class="separator:a909a29cb99261b06bc04251b588ce8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6ace970955eb827134d222311415a"><td class="memItemLeft" align="right" valign="top"><a id="a7de6ace970955eb827134d222311415a"></a>
static <a class="el" href="classgmds_1_1_face.html">gmds::Face</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNextFace</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;ANodeID, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;AFaceID, <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;<a class="el" href="classgmds_1_1_edge.html">Edge</a>)</td></tr>
<tr class="separator:a7de6ace970955eb827134d222311415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e104386ba8362dfe1d90ed08c92d75"><td class="memItemLeft" align="right" valign="top"><a id="a64e104386ba8362dfe1d90ed08c92d75"></a>
static <a class="el" href="classgmds_1_1_node.html">gmds::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCommonNode</b> (const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AEdge1, const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;AEdge2)</td></tr>
<tr class="separator:a64e104386ba8362dfe1d90ed08c92d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fe3540d4d610a68c02c30a3170f3c2"><td class="memItemLeft" align="right" valign="top"><a id="a43fe3540d4d610a68c02c30a3170f3c2"></a>
static <a class="el" href="classgmds_1_1_node.html">gmds::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCommonNode</b> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace1, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace2)</td></tr>
<tr class="separator:a43fe3540d4d610a68c02c30a3170f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938f6bbcebc155a9c69b2b612027e38"><td class="memItemLeft" align="right" valign="top"><a id="a9938f6bbcebc155a9c69b2b612027e38"></a>
static <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCommonEdge</b> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace1, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace2)</td></tr>
<tr class="separator:a9938f6bbcebc155a9c69b2b612027e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada0b605250ac1486bd3698730c63f2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0b605250ac1486bd3698730c63f2de">&#9670;&nbsp;</a></span>Tools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tools::Tools </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *&#160;</td>
          <td class="paramname"><em>AMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_variable.html">gmds::Variable</a>&lt; <a class="el" href="classgmds_1_1math_1_1_cross2_d.html">gmds::math::Cross2D</a> &gt; *&#160;</td>
          <td class="paramname"><em>AField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_variable.html">gmds::Variable</a>&lt; <a class="el" href="classgmds_1_1math_1_1_axis_angle_rotation.html">gmds::math::AxisAngleRotation</a> &gt; *&#160;</td>
          <td class="paramname"><em>ARotField</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AMesh</td><td>the mesh where we work on </td></tr>
    <tr><td class="paramname">AField</td><td>the cross field associated to AMesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3ea4ace0eab94e42a2404a77b9528af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ea4ace0eab94e42a2404a77b9528af">&#9670;&nbsp;</a></span>computeOutVectorAtPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::computeOutVectorAtPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>ANode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arriving at node ANode with direction AInVec, it returns the best fit direction prescribed by the cross field at ANode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ANode</td><td>the node we consider </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction we arrive </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ray intersects the edge, false otherwise </dd></dl>

</div>
</div>
<a id="a9cf3a24674d7ecd0cca2bb180ed06353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf3a24674d7ecd0cca2bb180ed06353">&#9670;&nbsp;</a></span>computeOutVectorFromRayAndEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::computeOutVectorFromRayAndEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>deviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let a ray r=[AInPnt, AInVec) interesecting an edge AEdge, this method returns the point of intersection P between r and AEdge, and the output vector at P, that respects the underlying cross field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AEdge</td><td>the edge we intersect </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after </td></tr>
    <tr><td class="paramname">deviation</td><td>deviation of the resulted line wrt the closest component of the cross at the intersection point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ray intersects the edge, false otherwise </dd></dl>

</div>
</div>
<a id="a0a7d60ad11d5c251f5ae3c632f1f6b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7d60ad11d5c251f5ae3c632f1f6b88">&#9670;&nbsp;</a></span>findNextCell() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::findNextCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AToCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AToCellID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the next cell we will got through. It is a face (dim=2), or an edge (dim=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[IN]</td><td>AFromPnt the geometric point we start from </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromVec the geometric direction we go along </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromEdge the edge we come from </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellDim the dim. of the mesh cell we start from (0 or 1) </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellID the id of the mesh cell we start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5dcbb92c65644d3786fd6c384a49cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dcbb92c65644d3786fd6c384a49cb8">&#9670;&nbsp;</a></span>findNextCell() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::findNextCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AToCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AToCellID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the next cell we will got through. It is a face (dim=2), or an edge (dim=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[IN]</td><td>AFromPnt the geometric point we start from </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromVec the geometric direction we go along </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromNode the node we come from </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellDim the dim. of the mesh cell we start from (0 or 1) </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellID the id of the mesh cell we start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c0eaf7692fc920e2bd10307183ff57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0eaf7692fc920e2bd10307183ff57d">&#9670;&nbsp;</a></span>findNextCell() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::findNextCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AFromCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>AFromCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AToCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AToCellID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the next cell we will go through. It is a face (dim=2), or an edge (dim=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[IN]</td><td>AFromPnt the geometric point we start from </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromVec the geometric direction we go along </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromCellDim the dim. of the mesh cell we start from (0 or 1) </td></tr>
    <tr><td class="paramname">[IN]</td><td>AFromCellID the id of the mesh cell we start from </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellDim the dim. of the mesh cell we start from (0 or 1) </td></tr>
    <tr><td class="paramname">[OUT]</td><td>AToCellID the id of the mesh cell we start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a626e6c255ffa3765b6c9a2e32f457ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e6c255ffa3765b6c9a2e32f457ac0">&#9670;&nbsp;</a></span>findTriangleAndNextVectorRK4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::findTriangleAndNextVectorRK4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AINPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>v_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>v_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>AEndOnBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ATriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AToCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AToCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isFinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previousVisitedFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the next RK4 vector at a <code>point_1</code> knowing that we have started from face <code>AFace</code> in this function we only know in which triangle(<code>AFace</code>) our initial point was located; therefore we have to find in which triangle <code>point_1</code> is located </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AINPnt</td><td>the original departing point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_x</td><td>the point at the current iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v_in</td><td>the initial vector (whoose direction should be followed as close as possible by v_next) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_next</td><td>the next RK4 vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">previousVisitedFaceq</td><td>the triangles that have been visited previously (or the singularity triangle for the first computation) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AEndOnBdry</td><td>boolean value indicating if we have reached the boundary </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BdryPnt</td><td>in case we have reached the boundary (AEndOnBdry == true), this is the final boundary point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AToCellDim</td><td>the dimension of the last visited element (node, edge, face) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AToCellID</td><td>the id of the last visited element (node, edge, face) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isFinal</td><td>boolean value indicating if we are athe last iteration of the RK4 step (in this case, AToCellDim and AToCellID must be modified to point to the actual element on whoch our last point lands) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a787551b6cbd4c1f2f91fe8d053dca50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787551b6cbd4c1f2f91fe8d053dca50e">&#9670;&nbsp;</a></span>followFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::followFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_tools_1_1_point_volumetric_data.html">PointVolumetricData</a> &amp;&#160;</td>
          <td class="paramname"><em>AData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>AMaxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute where the frame field defined by m_axis_angle will transport <code>AData.pnt</code> considering data in <code>AData</code> and the max distance is <code>AMaxDist</code>. </p>
<p><a class="el" href="class_this.html">This</a> algorithm uses Heun's scheme + a fuzzy approch where we always go in/out of simplex along faces</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AData</td><td>point data in the flow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AMaxDist</td><td>Maximum distance allowed for the displacement</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">APnt</td><td>the reached location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if APnt has been computed, false if we reach a tet being FF singular </dd></dl>

</div>
</div>
<a id="a29d72075e5590992843fd044bf1af8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d72075e5590992843fd044bf1af8ae">&#9670;&nbsp;</a></span>getNextVectorRK4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::getNextVectorRK4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambdas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>v_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>v_next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the next RK4 vector at a <code>point_1</code> inside face <code>AFace</code> this function assumes we have already checked and <code>point_1</code> is in triangle <code>AFace</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_1</td><td>a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AFace</td><td>a triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambdas</td><td>weights for barycentric coordinates of point <code>point_1</code> inside triangle <code>AFace</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v_in</td><td>the initial vector (whoose direction should be followed as close as possible by v_next) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_next</td><td>the next RK4 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a83c3184f53a7e2bf31f472828ace4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a83c3184f53a7e2bf31f472828ace4">&#9670;&nbsp;</a></span>heunsComputation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tools::heunsComputation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AOppNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AInNode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AInNode2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutEdge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutEdge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>deviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Heun's algorithm into a triangle to compute the out point when we go through this triangle and we arrive from an edge. Note that the algorithm is numerically corrected to avoid to go back in the face we come from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AInEdge</td><td>the edge we come from </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AOppNode</td><td>the node opposite to AInEdge </td></tr>
    <tr><td class="paramname">AInNode1</td><td>the first node of AInEdge </td></tr>
    <tr><td class="paramname">AInNode2</td><td>the second node of AInEdge </td></tr>
    <tr><td class="paramname">AOutEdge1</td><td>another edge of the face we work on </td></tr>
    <tr><td class="paramname">AOutEdge2</td><td>a second another edge of the face we work on </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an index indicating which is the cell we go out through:<ul>
<li>1 for AOppNode</li>
<li>2 for AInNode1</li>
<li>3 for AInNode2</li>
<li>4 for AOutEdge1</li>
<li>5 for AOutEdge2 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac7856231d1e36890d39fb9cd5ddc0573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7856231d1e36890d39fb9cd5ddc0573">&#9670;&nbsp;</a></span>heunsComputation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tools::heunsComputation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AOppNode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AOppNode2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AOppEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>deviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Heun's algorithm into a triangle to compute the out point when we go through this triangle and we arrive from a node. Note that the algorithm is numerically corrected to avoid to go out from the triangle we get in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AInNode</td><td>the node we come from </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AOppNode1</td><td>the first node of AOppEdge </td></tr>
    <tr><td class="paramname">AOppNode2</td><td>the second node of AOppEdge </td></tr>
    <tr><td class="paramname">AOppEdge</td><td>the edge opposite to AInNode </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an index indicating which is the cell we go out through:<ul>
<li>0 if it does not intersect</li>
<li>1 for AOppNode1</li>
<li>2 for AOppNode2</li>
<li>3 for AOppEdge </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a006d70280bd2b56e1692c79014c07338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006d70280bd2b56e1692c79014c07338">&#9670;&nbsp;</a></span>isAlong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::isAlong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the ray starting from AFromNode and following AVec is aligned with AEdge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AVec</td><td>a direction modelized by a vector </td></tr>
    <tr><td class="paramname">AFromNode</td><td>the node we start from </td></tr>
    <tr><td class="paramname">AEdge</td><td>an edge incident to AFromNode (otherwise returns false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean indicating if the AVec is aligned with AEdge </dd></dl>

</div>
</div>
<a id="ad376f04fa751eb4bd6369a55ba1d5f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad376f04fa751eb4bd6369a55ba1d5f97">&#9670;&nbsp;</a></span>isGoingInto() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::isGoingInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the ray starting from APnt and following AVec is going into the face AFace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">APnt</td><td>the starting point </td></tr>
    <tr><td class="paramname">AVec</td><td>a direction modelized by a vector </td></tr>
    <tr><td class="paramname">AFromEdge</td><td>the edge of AFace, that contains APnt </td></tr>
    <tr><td class="paramname">AFace</td><td>the face we want to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean </dd></dl>

</div>
</div>
<a id="a26d696b02ff4c33dd03418920e8e5802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d696b02ff4c33dd03418920e8e5802">&#9670;&nbsp;</a></span>isGoingInto() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::isGoingInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the ray starting from APnt and following AVec is going into the face AFace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">APnt</td><td>the starting point </td></tr>
    <tr><td class="paramname">AVec</td><td>a direction modelized by a vector </td></tr>
    <tr><td class="paramname">AFromNode</td><td>the node of AFace, that is located at APnt </td></tr>
    <tr><td class="paramname">AFace</td><td>the face we want to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean </dd></dl>

</div>
</div>
<a id="a242e539d4ff1d2144929d585f545bbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242e539d4ff1d2144929d585f545bbce">&#9670;&nbsp;</a></span>isPntInTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tools::isPntInTri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>ATri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>AOnEdge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>AOnEdge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>AOnEdge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a point <code>APnt</code> projected onto the plane defining <code>ATri</code> belong to <code>ATri</code> or not. Boolean <code>AOnEdge0</code>, <code>AOnEdge1</code> and <code><code>AOnEdge2</code> indicates</code> if the points lies on the edge o opposite to node 0, 1 and 3 respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APnt</td><td>a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATri</td><td>a triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOnEdge0</td><td>true if APnt lies on the edge opposite to the node 0 of <code>ATri</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOnEdge1</td><td>true if APnt lies on the edge opposite to the node 1 of <code>ATri</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOnEdge2</td><td>true if APnt lies on the edge opposite to the node 2 of <code>ATri</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>APnt</code> is in <code>ATri</code>, false otherwise </dd></dl>

</div>
</div>
<a id="a7c8854071658eff0adb198c8a9c59f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8854071658eff0adb198c8a9c59f70">&#9670;&nbsp;</a></span>removeBoundarySlivers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tools::removeBoundarySlivers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *&#160;</td>
          <td class="paramname"><em>AMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes boundary slivers for a mesh with R|N|R2N|N2R model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AMesh</td><td>the mesh to work on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a577ffce8d9d01df14679e4d37538d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a577ffce8d9d01df14679e4d37538d7">&#9670;&nbsp;</a></span>RK4Computation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::RK4Computation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AINPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AINVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOUTPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOUTVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>deviation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>stepSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>AEndOnBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ATriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AToCellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AToCellID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Runge-Kutta algorithm into a triangle to compute the out point when we go through this triangle and we arrive from an edge. Note that the algorithm is numerically corrected to avoid to go back in the face we come from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">AINPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">AINVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOUTPnt</td><td>the geometric point we go out (in case we arrive at boundary -&gt; the obtained bdry point) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOUTVec</td><td>the geometric direction to follow after </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">deviation</td><td>measure of the deviation from the field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stepSize</td><td>the step size for the algorithm (∆t) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AEndOnBdry</td><td>boolean value indicating if we have arrived to the boundary </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AToCellDim</td><td>the dimension of the last visited element (node, edge, face) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AToCellID</td><td>the id of the last visited element (node, edge, face) </td></tr>
  </table>
  </dd>
</dl>
<p>int AToCellDimNew = AToCellDim;</p>

</div>
</div>
<a id="a6342c91c1d06ba72ac88fc9d0442cac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6342c91c1d06ba72ac88fc9d0442cac7">&#9670;&nbsp;</a></span>traverseTriangle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::traverseTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>AEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AOutCellDIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>streamlineDeviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the out point when we go through a triangle following the cross field and starting from an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AFace</td><td>the face we work on </td></tr>
    <tr><td class="paramname">AEdge</td><td>the edge we come from </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after </td></tr>
    <tr><td class="paramname">AOutCellDim</td><td>the dimension of the cell we go out </td></tr>
    <tr><td class="paramname">AOutCellID</td><td>the id of the cell we go out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fba6f52deed9997e1a0890b0b9fe0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fba6f52deed9997e1a0890b0b9fe0d2">&#9670;&nbsp;</a></span>traverseTriangle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::traverseTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AInCellDIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>AInCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AOutCellDIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>streamlineDeviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the out point when we go through a triangle following the cross field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AFace</td><td>the face we work on </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AInCellDim</td><td>the dimension of the cell start_pnt is located </td></tr>
    <tr><td class="paramname">AInCellID</td><td>the id of the cell start_pnt is located on </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after </td></tr>
    <tr><td class="paramname">AOutCellDim</td><td>the dimension of the cell we go out </td></tr>
    <tr><td class="paramname">AOutCellID</td><td>the id of the cell we go out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890fcfeb7ece1f554d208c0da8cfa061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890fcfeb7ece1f554d208c0da8cfa061">&#9670;&nbsp;</a></span>traverseTriangle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tools::traverseTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>ANode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AInPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AOutCellDIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutCellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>streamlineDeviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the out point when we go through a triangle following the cross field and starting from a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AFace</td><td>the face we work on </td></tr>
    <tr><td class="paramname">ANode</td><td>the node we come from </td></tr>
    <tr><td class="paramname">AInPnt</td><td>the geometric point we start from </td></tr>
    <tr><td class="paramname">AInVec</td><td>the geometric direction to follow </td></tr>
    <tr><td class="paramname">AOutPnt</td><td>the geometric point we go out </td></tr>
    <tr><td class="paramname">AOutVec</td><td>the geometric direction to follow after </td></tr>
    <tr><td class="paramname">AOutCellDim</td><td>the dimension of the cell we go out </td></tr>
    <tr><td class="paramname">AOutCellID</td><td>the id of the cell we go out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/gmds/gmds/singGraphBuild/inc/gmds/singGraphBuild/Tools.h</li>
<li>/home/runner/work/gmds/gmds/singGraphBuild/src/Tools.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
