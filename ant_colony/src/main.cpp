#include <gmds/utils/CommonTypes.h>
#include <gmds/math/Point.h>
#include <gmds/math/Matrix.h>
#include <gmds/ig/Mesh.h>
#include <gmds/igalgo/GridBuilder.h>
//#include <gmds/padding/SelectivePadding.h>
#include <gmds/ig/MeshDoctor.h>
#include <gmds/io/IGMeshIOService.h>
#include <gmds/io/VTKReader.h>
#include <gmds/io/VTKWriter.h>


#include <gmds/sheet/Selector3D.h>
#include <gmds/sheet/Collapse3D.h>
#include <gmds/igalgo/BoundaryExtractor3D.h>
#include <gmds/igalgo/BoundaryOperator.h>
/*----------------------------------------------------------------------------*/
#include <gmds/ant_colony/Env.h>
#include <optional>
/*----------------------------------------------------------------------------*/
#include <iostream>
#include <bitset>
#include <regex>
/*----------------------------------------------------------------------------*/
using namespace gmds;

std::vector<std::pair<TCellID, TCellID>> get_pair(std::string dir, std::vector<std::string> filenames);

std::string ReplaceAll(std::string str, const std::string &from, const std::string &to) {
    size_t start_pos = 0;
    while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
    }
    return str;
}

std::vector<TCellID> get_faces(std::string dir, std::vector<std::string> filenames);

typedef enum {
    candidate,
    constraint,
    not_in_set,
} FaceStatus;

/* DEP
void test() {
    // Problem initialize
    // Pb 1
    int exist_tens[3][3][3] = {{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}},
                               {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
                               {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
    int *exist_flatten = &exist_tens[0][0][0];
    // Env test
    gmds::Env env(3, 3, 3, exist_flatten);
    env.writeVTK("env.vtk");
    std::vector<TCellID> frontb = {45};
    std::vector<char> solution(env.getNbFaces(), 0);
    for (auto x: frontb) {
        solution[x] = 1;
    }

    auto edges_of_front = env.getEdgesOfFront(frontb, solution);
    for (auto e: edges_of_front) {
        std::cout << e << " ";
    }
    std::cout << std::endl;

    auto candidates = env.getFacesCandidates(edges_of_front, solution);
    for (auto c: candidates) {
        std::cout << c << " ";
    }
    std::cout << std::endl;

    frontb = {29};

    env.updateFront(frontb);
    edges_of_front = env.getEdgesOfFront(frontb, solution);
    std::cout << "edges " << edges_of_front.size() << " : ";
    for (auto e: edges_of_front) {
        std::cout << e << " ";
    }
    std::cout << std::endl;
    candidates = env.getFacesCandidates(edges_of_front, solution);
    std::cout << "faces " << candidates.size() << " : ";
    for (auto c: candidates) {
        std::cout << c << " ";
    }
    std::cout << std::endl;
    std::cout << "\n\n#Start Front " << std::endl;
    env.resetVariables();

    env.setVerbosity(Verbosity::No);
    std::vector<TCellID> front_initial = {42, 40};
    env.execute(front_initial);
    //std::cout << "Edge turn " << env.numberEdgeTurn(solu) << std::endl;

    std::vector<char> s;
    env.setVerbosity(Verbosity::Yes);
    s = env.run(front_initial);
    env.writeSolution(s, front_initial, "Inspect.vtk");
    std::cout << "Solution" << ' ';
    for (auto x: s) {
        std::cout << x << ' ';
    }
    std::cout << std::endl;
}*/

void model1() { // 1*3*3

    int exist_tens[3][3][3] = {{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}},
                               {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
                               {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
    // Flatten
    int *exist_flatten = &exist_tens[0][0][0];
    gmds::Env env(3, 3, 3, exist_flatten);
    env.setup_ant_colony_params(1, 1, 0.5f, 0.0f, 1.0f, 10, 2);
    std::vector<std::pair<TCellID, TCellID>> front = {std::pair<TCellID, TCellID>(46, 44)};
    env.setup_intial_front_and_edges(front);
    std::vector<float> pheromone(env.getNbFaces(), 0.0f);

    //env.run_ant(front, pheromone);
    env.execute();
}

void prepare_model(){
    // pointer, dim
    std::vector<std::pair<int*,int>> models;
    std::vector<std::vector<TCellID>> initial_faces;
    std::vector<std::string> filename;
    int dim;
    // 1_3_3 SLICE MODEL
    int exist_tens0[3][3][3] = {{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}},
                               {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
                               {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
    dim = 3;
    models.push_back(std::make_pair(&exist_tens0[0][0][0],dim));
    initial_faces.push_back({41, 39});
    filename.push_back("1_3_3slice.vtk");
    // 2_3_3
    int exist_tens1[3][3][3] = {{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}},
                               {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
                               {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}};
    dim = 3;
    models.push_back(std::make_pair(&exist_tens1[0][0][0],dim));
    initial_faces.push_back({41,39,74,73});
    filename.push_back("2_3_3slice.vtk");
    // 1_1_3
    int exist_tens2[3][3][3] = {{{1, 1, 1}, {0, 0, 0}, {0, 0, 0}},
                               {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}},
                               {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
    dim = 3;
    models.push_back(std::make_pair(&exist_tens2[0][0][0],dim));
    initial_faces.push_back({0,1,2,3,4});
    filename.push_back("1_1_3slice.vtk");
    // Model weak
    int exist_tens3[4][4][4] = {{{0, 0, 1, 1},{0, 0, 1, 1},{1, 1, 1, 1},{1, 1, 1, 1}},
                               {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}},
                               {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}},
                               {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}}};
    dim = 4;
    models.push_back(std::make_pair(&exist_tens3[0][0][0],dim));
    initial_faces.push_back({0, 1});
    filename.push_back("model_weak.vtk");

    // Model weak 3D
    int exist_tens4[4][4][4] = {{{0, 0, 1, 1},{0, 0, 1, 1},{1, 1, 1, 1},{1, 1, 1, 1}},
                                {{0, 0, 1, 1},{0, 0, 1, 1},{1, 1, 1, 1},{1, 1, 1, 1}},
                                {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}},
                                {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}}};
    dim = 4;
    models.push_back(std::make_pair(&exist_tens4[0][0][0],dim));
    initial_faces.push_back({0,1,4});
    filename.push_back("model_weak_3D.vtk");

    //
    int exist_tens5[8][8][8] = {{{0, 0, 0, 0, 1, 1, 1, 1},{0, 0, 0, 0, 1, 1, 1, 1},{0, 0, 0, 0, 1, 1, 1, 1},{0, 0, 0, 0, 1, 1, 1, 1},{1, 1, 1, 1, 1, 1, 1, 1},{1, 1, 1, 1, 1, 1, 1, 1},{1, 1, 1, 1, 1, 1, 1, 1},{1, 1, 1, 1, 1, 1, 1, 1}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}},
                               {{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0}
                               }};
    dim = 8;
    models.push_back(std::make_pair(&exist_tens5[0][0][0],dim));
    initial_faces.push_back({0,1});
    filename.push_back("model_strong.vtk");

    //
    int exist_tens6[4][4][4] = {{{1, 1, 1, 1},{1, 1, 1, 1},{1, 1, 1, 1},{1, 1, 1, 1}},
                               {{0, 0, 0, 0},{0, 1, 1, 0},{0, 1, 1, 0},{0, 0, 0, 0}},
                               {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}},
                               {{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}}};
    dim = 4;
    models.push_back(std::make_pair(&exist_tens6[0][0][0],dim));
    filename.push_back("model_column_easy.vtk");
    initial_faces.push_back({72,73,77,80,87,86,83,81});

    int exist_tens7[2][2][2] = {{{1,1},{1,1}},{{1,1},{1,1}}};
    dim=2;
    models.push_back(std::make_pair(&exist_tens7[0][0][0],dim));
    filename.push_back("cube_2_2_2.vtk");
    initial_faces.push_back({0,1,4});

    int exist_tens8[3][3][3] = {{{1,1,1},{1,1,1},{1,1,1}},{{1,1,1},{1,1,1},{1,1,1}},{{1,1,1},{1,1,1},{1,1,1}}};
    dim=3;
    models.push_back(std::make_pair(&exist_tens8[0][0][0],dim));
    filename.push_back("cube_3_3_3.vtk");
    initial_faces.push_back({0,1,4});

    int exist_tens9[5][5][5] =
            {{{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}},
             {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}},
             {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}},
             {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}},
             {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}}
            };
    dim=5;
    models.push_back(std::make_pair(&exist_tens9[0][0][0],dim));
    filename.push_back("cube_5_5_5.vtk");
    initial_faces.push_back({0,1,4});

    int exist_tens10[10][10][10] = {
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}}
    };
    dim=10;
    models.push_back(std::make_pair(&exist_tens10[0][0][0],dim));
    filename.push_back("cube_10_10_10.vtk");
    initial_faces.push_back({0,1,4});

    //!
    for( int i= 0; i < initial_faces.size() ; i++) {
        gmds::Env env(models[i].second, models[i].second, models[i].second, models[i].first);
        env.set_initial_faces(initial_faces[i]);
        env.initialize_ant_bis(initial_faces[i]);
        env.writeVTK(filename[i]);
    }

}

void model_column() { // not working with 3 faces selected
    int exist_tens[15][15][15] =
            {{{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
             },
             {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             },
             {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
             }
            };

    int *exist_flatten = &exist_tens[0][0][0];
    gmds::Env env(15, 15, 15, exist_flatten); // 8 8 8 is fun
    env.setup_ant_colony_params(1, 1, 0.5f, 0.0f, 2.0f, 1, 1);
    //env.writeVTK("model_column_3D.vtk");
    //env.write_R("R_model_column_3D.vtk"); dont work
    std::string dir("data/");
    std::vector<std::string> files = {"0.csv", "1.csv", "2.csv", "3.csv", "4.csv", "5.csv", "6.csv", "7.csv"};
    auto p = get_pair(dir, files);
    env.setup_intial_front_and_edges(p);
    //env.setup_intial_front_and_edges("selection_column.csv");

    env.status();
    std::vector<char> solution(env.getNbFaces(), 0);
    std::vector<TCellID> faces = get_faces(dir, files);
    for (auto f: faces) {
        solution[f] = 1;
    }

    //env.writeSolution(solution,"column_init.vtk",{});
    //env.execute();

}

void cube_3_3_3(){

    /* Writing the best solution known
    std::string best_solution = "111110111101111000010001000100001000100010010001000100000000000000000000000010001000100000000000000000000000";
    std::vector<char> bs;
    for (std::size_t i = 0; i < best_solution.size(); i++) {
        // Simply convert char '0' or '1' to int
        bs.push_back(static_cast<int>(best_solution[i]) - '0');
    }
    std::vector<char> flip_on = {42,55,65, 75, 88, 98, 16, 29};
    for(auto x : flip_on){
        bs[x] = 1;
    }
    std::vector<char> flip_off ={3, 8, 13,2, 7 ,12};
    for(auto x : flip_off){
        bs[x] = 0;
    }
    std::cout << "SOLUTION QUALITY " << env.solution_quality(bs) << std::endl;
    */
}

void cube_3_3_3_newalg(){
    int exist_tens[3][3][3] = {{{1,1,1},{1,1,1},{1,1,1}},{{1,1,1},{1,1,1},{1,1,1}},{{1,1,1},{1,1,1},{1,1,1}}};
    int *exist_flatten = &exist_tens[0][0][0];
    float tmin = 1.0, tmax = 10.0;
    gmds::Env env(3, 3, 3, exist_flatten); // 8 8 8 is fun
    env.setup_ant_colony_params(1, 1, 0.9f, 1.0f, 10.0f,100,100,3);
    float tau_min = 1.0, tau_max = 2.0;
    std::vector<float> pheromone(env.getNbFaces(), tau_max);
    env.writeVTK("cube_3_3_3.vtk");
    env.set_write(false);
    env.status();
    std::vector<TCellID> initial_faces = {0,1,4};
    env.set_initial_faces(initial_faces);
    env.execute();
}

void cube_10_10_10_new_alg(){
    int exist_tens[10][10][10] = {
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
            {{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}}
    };

    int *exist_flatten = &exist_tens[0][0][0];
    gmds::Env env(10, 10, 10, exist_flatten); // 8 8 8 is fun
    env.setup_ant_colony_params(1, 1, 0.9f, 1.0f, 10.0f,3,3,1);
    float tau_min = 1.0, tau_max = 2.0;
    std::vector<float> pheromone(env.getNbFaces(), tau_max);
    env.writeVTK("cube_10_10_10.vtk");
    env.set_write(true);
    env.status();
    std::vector<TCellID> frontbis = {0,1,4};
    env.set_initial_faces(frontbis);
    //env.execute(frontbis);
    env.execute();
}
/*
 * Filename have to be in VTK format
 * Write file with face ids
 * */
void add_connectivity(std::string filename, std::string dirname_in, std::string dirname_out) {
    std::cout << "Add_connectivity" << std::endl;
    gmds::Mesh m(gmds::MeshModel(gmds::MeshModel(gmds::DIM3 | gmds::R | gmds::N | gmds::F | gmds::E |
                                                 gmds::F2N | gmds::R2N | gmds::E2N |
                                                 gmds::R2F | gmds::F2R | gmds::R2E | gmds::N2R)));
    std::cout << filename << std::endl;
    gmds::IGMeshIOService ioService(&m);
    gmds::VTKReader vtkReader(&ioService);
    vtkReader.setCellOptions(gmds::N | gmds::F | gmds::R);
    vtkReader.read(dirname_in + filename);

    gmds::MeshDoctor doc(&m);
    doc.buildFacesAndR2F();
    doc.buildEdgesAndX2E();
    doc.updateUpwardConnectivity();

    gmds::VTKWriter vtkWriter(&ioService);
    vtkWriter.setCellOptions(gmds::N | gmds::E | gmds::R);
    vtkWriter.setDataOptions(gmds::N | gmds::E | gmds::R);
    //std::string outfile = std::regex_replace(filename, std::regex("mesh"), "vtk");
    //std::cout << outfile << std::endl;
    vtkWriter.write(dirname_out + filename);
}

void the_dream() {
    std::cout << "Add_connectivity" << std::endl;
    std::string dirname_in("VTK/");
    std::string dirname_out("VTK_out/");
    std::string filename("Column.vtk");
    gmds::Mesh m(gmds::MeshModel(gmds::MeshModel(gmds::DIM3 | gmds::R | gmds::N | gmds::F | gmds::E |
                                                 gmds::F2N | gmds::R2N | gmds::E2N |
                                                 gmds::R2F | gmds::F2R | gmds::R2E)));
    std::cout << filename << std::endl;
    gmds::IGMeshIOService ioService(&m);
    gmds::VTKReader vtkReader(&ioService);
    vtkReader.setCellOptions(gmds::N | gmds::F | gmds::R);
    vtkReader.read(dirname_in + filename);

    gmds::MeshDoctor doc(&m);
    doc.buildFacesAndR2F();
    doc.buildEdgesAndX2E();
    doc.updateUpwardConnectivity();
    gmds::Face f1 = m.get<Face>(773), f2 = m.get<Face>(655);
    auto nodes = m.getCommonNodes(f1, f2);

    std::cout << "N: " << m.getNbNodes() << "\nE: " << m.getNbEdges() << "\nF: " << m.getNbFaces() << "\nR: "
              << m.getNbRegions() << std::endl;;

    Selector3D select(&m);
    assert(select.isValid());
    std::cout << "Nodes " << nodes.size() << std::endl;
    select.execute(nodes[0], nodes[1]);

    Collapse3D op(&m);
    std::cout << nodes[0] << " " << nodes[1] << std::endl;
    op.execute(nodes[0], nodes[1]);

    std::cout << m.getNbRegions() << std::endl;

    gmds::VTKWriter vtkWriter(&ioService);
    vtkWriter.setCellOptions(gmds::N | gmds::E | gmds::F | gmds::R);
    vtkWriter.setDataOptions(gmds::N | gmds::E | gmds::F | gmds::R);
    //std::string outfile = std::regex_replace(filename, std::regex("mesh"), "vtk");
    //std::cout << outfile << std::endl;
    vtkWriter.write(dirname_out + filename);
}


std::vector<TCellID> get_face_of_file(std::string filename) {
    std::vector<TCellID> faces;
    std::string line;
    std::ifstream myfile(filename);
    if (myfile.is_open()) {

        while (getline(myfile, line)) {
            std::cout << line << '\n';
            faces.push_back(std::stoi(line));
        }
        myfile.close();
    }
    return faces;
}

std::vector<std::pair<TCellID, TCellID>> get_pair(std::string dir, std::vector<std::string> filenames) {
    std::vector<std::pair<TCellID, TCellID>> pairs;
    std::vector<std::vector<TCellID>> trucs;
    for (auto f: filenames) {
        trucs.push_back(get_face_of_file(dir + f));
    }
    for (auto i = 0; i < filenames.size() - 1; i += 2) {
        for (auto j = 0; j < trucs[0].size() - 1; j += 2) {
            pairs.push_back(std::make_pair(trucs[i][j], trucs[i][j + 1]));
            pairs.push_back(std::make_pair(trucs[i + 1][j], trucs[i + 1][j + 1]));

            pairs.push_back(std::make_pair(trucs[i][j], trucs[i + 1][j]));
            pairs.push_back(std::make_pair(trucs[i][j + 1], trucs[i + 1][j + 1]));
        }
    }
    return pairs;
}

std::vector<TCellID> get_faces(std::string dir, std::vector<std::string> filenames) {
    std::vector<TCellID> res, tmp;
    for (auto f: filenames) {
        tmp = get_face_of_file(dir + f);
        res.insert(res.end(), tmp.begin(), tmp.end());
    }
    return res;
}
int *column_easy_pb() {
    static int exist_tens[4][4][4] = {{{1, 1, 1, 1},
                                              {1, 1, 1, 1},
                                              {1, 1, 1, 1},
                                              {1, 1, 1, 1}},
                                      {{0, 0, 0, 0},
                                              {0, 1, 1, 0},
                                              {0, 1, 1, 0},
                                              {0, 0, 0, 0}},
                                      {{0, 0, 0, 0},
                                              {0, 0, 0, 0},
                                              {0, 0, 0, 0},
                                              {0, 0, 0, 0}},
                                      {{0, 0, 0, 0},
                                              {0, 0, 0, 0},
                                              {0, 0, 0, 0},
                                              {0, 0, 0, 0}}};
    return &exist_tens[0][0][0];
}
std::vector<std::pair<TCellID, TCellID>> column_easy_initial_faces() {
    return {std::pair<TCellID, TCellID>(72, 73),
            std::pair<TCellID, TCellID>(77, 80),
            std::pair<TCellID, TCellID>(87, 86),
            std::pair<TCellID, TCellID>(83, 81)};
}

void test(){
    /*int exist_tens[4][4][4] = {{{0, 0, 1, 0},
                                       {0, 0, 1, 1},
                                       {0, 0, 1, 1},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}}};
    */
    int exist_tens[4][4][4] = {{{0, 0, 1, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}}};

    int *exist_flatten = &exist_tens[0][0][0];
    gmds::Env env(4, 4, 4, exist_flatten);
    env.writeVTK("test_end_condition.vtk");
}

void test2_2(){
    int exist_tens[4][4][4] = {{{0, 0, 1, 0},
                                       {0, 0, 1, 1},
                                       {0, 0, 1, 1},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}},
                               {{0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0},
                                       {0, 0, 0, 0}}};

    int *exist_flatten = &exist_tens[0][0][0];
    gmds::Env env(4, 4, 4, exist_flatten);
    env.writeVTK("test_end_condition.vtk");
    env.edges_to_add();
}


int main(int argc, char *argv[]) {
    std::cout << "==== Main Valentin Postat ====" << std::endl;
    std::cout << "./main [n_run] [n_iter] [n_ants] [tau_min] [tau_max] [alpha] [beta]" << std::endl;
    //int *c = column_easy_pb();
    //std::cout << c[0];
    /* work
    test2_2();
    model_column_easy();
    */
    //model_weak();
    //cube_2_2_2();
    //cube_3_3_3();
    prepare_model();
    Env e("1_3_3slice.vtk");
    e.status();
    e.set_write(0);
    e.setup_ant_colony_params(1,1,0.9,1.0,10.0,10,10,10);
    e.execute();
    std::cout << "Program finished" << std::endl;
    //e.writeVTK("1_3_3slice_read_write.vtk");
    //cube_3_3_3_newalg();
    //cube_10_10_10_new_alg();
    return 0;

    //return 0;
    if (argc == 8 + 1) {
        std::map<std::string, int *> models;
        std::map<std::string, std::vector<std::pair<TCellID, TCellID>>> initial_faces;
        std::map<std::string, std::vector<int>> dims;

        int nb_run = atoi(argv[1]), nb_iter = atoi(argv[2]), nb_ants = atoi(argv[3]);
        assert(nb_run >= 0 && nb_iter >= 0 && nb_ants >= 0);
        float tmin = atof(argv[4]), tmax = atof(argv[5]), p = atof(argv[6]), alpha = atof(argv[7]), beta = atof(
                argv[8]);
        std::cout << "Parameters: " << std::endl;
        std::cout << "\tnb_run " << nb_run << "\n\tnb_iter " << nb_iter << "\n\tnb_ants " << nb_ants
                  << "\n\t[tmin,tmax] [" << tmin << "," << tmax << "]\n\tp " << p << "\n\t[alpha,beta] [" << alpha
                  << "," << beta << "]" << std::endl;
    } else if (argc == 1) {
        std::cout << "Default execution" << std::endl;
        //model1();
        //model2();
        //model_strong();
        //model_column_easy();
        //model_weak_3D();
    } else if (argc == 4) {
        std::string filename(argv[1]);
        std::string dirname_in(argv[2]);
        std::string dirname_out(argv[3]);
        std::cout << "filename " << filename << std::endl;
        std::cout << "dir_name_in " << dirname_in << std::endl;
        std::cout << "dir_name_out " << dirname_out << std::endl;
        add_connectivity(filename, dirname_in, dirname_out);
    } else if (argc == 3) {
        std::cout << "Load the vtk [filename] and display [solution] in it" << std::endl;
        std::string solution(argv[1]);
        std::string filename(argv[2]);
        std::cout << "solution " << solution << std::endl;
        std::cout << "filename " << filename << std::endl;
        Env env(filename);
        env.setup_solution_from_string(solution);
    } else {
        std::cout << "Wrong number of arguments" << std::endl;
        std::cout << "Load the vtk [filename] and display [solution] in it" << std::endl;
        std::cout << "usage ./main [solution] [filename].vtk " << std::endl;
    }




    //model_column_easy();
    /*Env env("model_column_3D.vtk");
    env.setup_intial_front_and_edges("selection_column.csv");
    env.status();*/
    //model_weak();
    //model_column();
    return 0;
}