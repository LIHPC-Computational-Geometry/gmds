{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GMDS - Generic Mesh Data and Services","text":"<p>GMDS, for Generic Mesh Data &amp; Services,  is a set of C++ library written to provide mesh data  structures and algorithms to developers that intend to design meshing algorithms and build pipelines of algorithms.</p> <p>The development of this library started a few years ago to provide a generic way of designing data structures  representing unstructured 2D and 3D meshes. Such meshes are defined as collections of cells that are topologically  connected. Cells can be:</p> <ul> <li>Nodes, or 0-dimensional cells (0-cells),</li> <li>Edges, or 1-dimensional cells (1-cells),</li> <li>Faces, or 2-dimensional cells (2-cells),</li> <li>Regions, or 3-dimensional cells (3-cells).</li> </ul> <p>Depending on the meshing algorithm a developer has to write, he must decide which cells are mandatory and which  topological connections. Indeed, for an algorithm you may need to store edges and/or faces with the relation from nodes  to edges and to faces and vice-versa, while for another you may require regions and the topological relation from faces  to regions. GMDS provide flexible mechanisms to handle a huge variety of models and type of cells (triangles,  quadrilaterals, tetrahedra, ...).</p> <p>As we are mainly concerned about structured meshes in our team, most of proposed algorithms are dedicated to  quadrilateral and hexahedral meshes.</p>"},{"location":"#a-generic-mesh-data-structure","title":"A generic mesh data structure","text":"<p>The data structures we provide are based onto the definition of a mesh model, which describes the available cells and  connections in the mesh. For instance, in the next example code (line 2), a model is defined with flags <code>DIM3|F|E|N|F2N|E2N|N2F</code>.  It means that the mesh is a 3D one (<code>DIM3</code>) made of faces (<code>F</code>), edges (<code>E</code>) and nodes (<code>N</code>), and connections from  faces to nodes (<code>F2N</code>), edges to nodes (<code>E2N</code>) and nodes to faces (<code>N2F</code>) are explicitly stored.</p> <p>Then we define a mesh with this model (line 3). We read nodes and faces of a vtk file in the block of instructions going from lines 5 to 9 (see the io module user guide for more details). Line 11 to 14 show how we can  iterate on the mesh nodes. </p> <pre><code>using namespace gmds;\nMeshModel model(DIM3|F|E|N|F2N|E2N|N2F); \nMesh m(model);\n\nIGMeshIOService ioService(&amp;m);\nVTKReader vtkReader(&amp;ioService); \nvtkReader.setCellOptions(N|F);\nvtkReader.setDataOptions(N|F);\nvtkReader.read(\"B21.vtk\");\n\nfor(auto node_id: m.nodes()){\n    Node n = m.get&lt;Node&gt;(node_id);\n    Point p = n.point();\n}\n</code></pre>"},{"location":"#algorithms-as-services","title":"Algorithms as services","text":"<p>gmds provides data structures, io services and math functionalities for developing meshing algorithms. </p>"},{"location":"#object-oriented-approach-for-meshing-algorithms","title":"Object-oriented approach for meshing algorithms","text":"<p>algorithms are gathered in modules, and we apply an object-oriented approach where each main algorithm is handled by a single class instance. For instance, in the  next code, an instance of the <code>CrossFieldGeneration2D</code> class is created. It acts on a mesh <code>m</code>. We run the algorithm with the <code>execute</code> method.</p> <pre><code>CrossFieldGeneration2D field_generator(&amp;m);\nfield_generator.execute(CrossFieldGeneration2D::laplace_solve);\n</code></pre>"},{"location":"#main-algorithms","title":"Main algorithms","text":"<p>Our current interest is about structured quadrilateral and hexahedral meshing. To generate such meshes, we focus on  several technologies including the following ones:</p> <ul> <li>Frame Fields. 3 modules are currenly dedicated to the usage of frame fields fo meshing<ul> <li>The frame module provides algorithms for 2D meshing. It relies on the notion of cross  fields (see the math component for cross definitions). Output of this module are 2D cross fields  defined on an input simplex mesh.</li> <li>The singGraphBuild module provides algorithm to extract the base complex structure of a 2D frame field</li> <li>The frame3d module provides algorithms for 3D frame field generation. Unlike the 2D case, we are not able to generate a full block structure but such fields are used to drive hybrid mesh generation and point generation algorithms.</li> </ul> </li> <li>Overlay grids algorithms, where an object O is embedded into a regular grid that is progressively adapted to capture the boundary features of O.</li> <li>Sheet operations. This module provides sheet operations for quad and hex meshes.</li> </ul>"},{"location":"#how-to-use-gmds","title":"How to use gmds","text":"<p>Two options are possible:</p>"},{"location":"#users-and-developers-documentation","title":"Users and developers documentation","text":"<p>Documentation is under construction. we just start to write it. It is split between: - Users documentation, which is dedicated to people who want to use gmds as a set of libraries but do not expect to contribute to it. - Developers documentation, which is dedicated to developers who would like to create a new gmds module for instance. In particular, we explain the git workflow that we adopted. - Gitub pages are under construction and available here.</p>"},{"location":"#installation","title":"Installation","text":"<p>gmds depends on many external components. On linux systems, and macos, we rely on  spack  for installing gmds depencies but also gmds. In a nutshell, spack allows you to install a set of libraries in a specific directory. You can see it as an equivalent of Python environment. </p>"},{"location":"#example-project-using-gmds","title":"Example Project using gmds","text":"<p>We provide a blank project example  showing how to use gmds as a library with CMake. You can run it with the following command  lines</p> <pre><code> cd docs/example\n cmake -DCMAKE_PREFIX_PATH=&lt;path_to_gmds_install_dir&gt; .\n make\n ./examplegmds\n</code></pre> <p>Feel free to copy or fork this project as a way of starting a new personal project using gmds.</p>"},{"location":"#coding-guidelines-and-tips","title":"Coding Guidelines and Tips","text":"<p>GMDS follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project.</p>"},{"location":"dev-guide/developers_doc/","title":"Developer documentation","text":""},{"location":"dev-guide/developers_doc/#setting-your-development-environment","title":"Setting your development environment","text":"<p>gmds depends on many external components. In order to compile gmds they need to be installed properly in order to be used with CMake.</p> <p>Some are optional depending on the gmds functionalities we want to activate; they include for example: - <code>lcov</code> is used to perform code coverage locally to your computer; - <code>py-pybind11</code> is mandatory for the python API; - <code>glpk</code> is a linear programming solver that we used in some of our gmds basic components; - <code>googletest</code> is used for our testing infrastructure; - <code>cgal</code> is required for the blocking component.</p> <p>On linux systems and macOS we suggest using spack for installing the dependencies.  We use this system for our CI workflows. In a nutshell, spack allows you to install a set of libraries in a  specific directory. You can see it as an equivalent of Python environment. In our context, we will simply install the set of dependencies we need and use them in our CMake build system. As an example, let's take a look at how to install the basic set of gmds components, plus the blocking component with the Python API and  with the CGNS writer.</p>"},{"location":"dev-guide/developers_doc/#installation-of-dependencies-with-spack","title":"Installation of dependencies with spack","text":"<p>The following procedure can be found in the build_spack_gmds.sh script. You can run the following commands from an empty directory; you will end up with three directories <code>spack, spack_recipes and gmds</code>. Spack's prerequisites for the version of your choice  should be installed.</p> <p>We download a spack release; optionally you can remove the configuration files  stored in the <code>.spack</code> directory located in your home if you have previously used spack and want a fresh start: <pre><code>#==========================================\n# First get a spack release\ngit clone --depth=1 -b v0.20.3  https://github.com/spack/spack.git\n\n#==========================================\n# can be mandatory if you have already used spack on your computer\n# delete the .spack directory in the home of the user in order to \n# have a fresh start\n</code></pre></p> <p>The way to build software in spack is described in what is called <code>recipes</code>, and ours  are located in this project: <pre><code>#==========================================\n# get our recipes\ngit clone --depth=1 https://github.com/LIHPC-Computational-Geometry/spack_recipes.git\n````\n\nSpack can be configured; you can modify the installation directory to shorten the paths at the cost\nof disabling the possibility to have several installations of a same package with differing\noptions/versions (if choosing that any library `toto` installed with spack will be located in  `absolute_path/spack/opt/spack/toto/`.)\n```bash\n# Optional: modifying the install_tree variable to make it shorter and more human readable;\n# the HASH part in install directory names is removed which can lead to collisions.\n# The spack/etc/spack/defaults/config.yaml file can be modified by hand\n# - in spack version 0.20\n#sed -i 's#\"{architecture}/{compiler.name}-{compiler.version}/{name}-{version}-{hash}\"#\"{name}\"#g' spack/etc/spack/defaults/config.yaml\n</code></pre></p> <p>Spack comes with builtin recipes; still we have to register additional ones:  - recipes for our own software, in particular gmds itself; - superseded recipes that replace the builtin ones; we aim to keep this number low and directly contribute  to the spack upstream project <pre><code># to register our recipes; it assumes that spack_recipes and spack are located at\n# the same level. You can use the \"spack repo add\" commands instead of copying the repos.yaml file\n#spack repo add ./spack_recipes/meshing\n#spack repo add ./spack_recipes/meshing_supersede\ncp spack_recipes/config/repos.yaml spack/etc/spack/defaults/repos.yaml\n</code></pre></p> <p>We will start using spack itself <pre><code>#==========================================\n# configure spack using spack commands; it modifies the .spack directory in the user home\nsource spack/share/spack/setup-env.sh\nspack clean -a\n</code></pre></p> <p>First register cmake (<code>cmake</code> should be available in your <code>PATH</code>,  for example by installing the system package) <pre><code># registering cmake\nspack external find cmake\n</code></pre></p> <p>And then compilers; you need a compiler that handles both C and CXX. Check that the highest version of the compiler returned by <code>spack compiler list</code> does indeed provide both, using the command <code>spack compiler info gcc</code> <pre><code># registering compilers\nspack compiler find\n# spack uses the highest version of the compiler found by default; if it is incomplete,\n# for example the C compiler is installed but not the CXX one the installations will fail.\n# Compilers found can be investigated by (see `spack help compiler` commands)\nspack compiler list\n#spack compiler info gcc\n# An undesirable version can be removed by editing ~/.spack/linux/compilers.yaml or using\n#spack compiler remove gcc@12\n</code></pre></p> <p>Now we get gmds: <pre><code># install for dev purposes\n# choose one URL depending on your authentication on github\n# web URL\ngit clone https://github.com/LIHPC-Computational-Geometry/gmds.git\n# SSH key\ngit clone git@github.com:LIHPC-Computational-Geometry/gmds.git\n</code></pre></p> <p>And we build gmds from the sources we just cloned, including all the necessary dependencies. The options given as parameters in this example are : - <code>~python~blocking~cgns</code> deactivates the corresponding variants, which will result in a lighter gmds with less dependencies - <code>dev_path</code> the path where the gmds sources are located - <code>build_type</code> the build type, <code>Debug</code> being most likely what one will need when developing</p> <pre><code># you will probably want build_type=Debug or RelWithDebInfo.\n# Choose the variants you need, you can check them using `spack info gmds`.\n# The dev_path option does not seem to handle relative paths.\n\n# +mpi should actually be ok, but currently the default openmpi install fails\n# It is activated by default in the hdf5 and cgns recipes, so choose not to use it if necessary\n#spack install gmds+python+blocking+cgns dev_path=$PWD/gmds build_type=Debug ^cgns~mpi ^hdf5~mpi\nspack install gmds~python~blocking~cgns dev_path=$PWD/gmds build_type=Debug\n</code></pre>"},{"location":"dev-guide/developers_doc/#configuring-the-ide","title":"Configuring the IDE","text":"<p>Now in order to develop we need to configure an IDE. This can be done in two ways: 1. Extracting the options from spack. Files named <code>gmds/spack-*</code> or <code>gmds/Buildxxx/spack-*</code> were created in the gmds directory; we can extract the necessary  data to configure an IDE, in particular the <code>CMAKE_PREFIX_PATH</code> and the cmake options given to gmds. <pre><code># to configure an IDE\n# spack created files and directories named gmds/spack-* in the gmds source tree, where the necessary\n# options are set up\n# get the CMAKE_PREFIX_PATH with ';' as separators\ncat gmds/spack-build-env.txt  | grep CMAKE_PREFIX_PATH | awk -F \"=\" {'print $2'} | awk -F \";\" {'print $1'} | sed 's/:/;/g'\n\n# get the cmake options that were explicitly set by spack; add -DWITH_TEST:BOOL=ON\n# to activate the tests\ncat gmds/spack-configure-args.txt\n</code></pre></p> <ol> <li>Specifying the options by hand; note that you can proceed this way whatever the method used to install the dependencies: <pre><code>-DWITH_PYTHON_API:BOOL=ON\n-DENABLE_BLOCKING:BOOL=ON\n-DWITH_CGNS:BOOL=ON\n-DWITH_TEST:BOOL=ON\n-DCMAKE_PREFIX_PATH=/absolute_path/spack/opt/spack/googletest;/absolute_path/spack/opt/spack/py-pybind11;/absolute_path/spack/opt/spack/cgal;/absolute_path/spack/opt/spack/gmp;/absolute_path/spack/opt/spack/mpfr;/absolute_path/spack/opt/spack/boost;/absolute_path/spack/opt/spack/glpk;/absolute_path/spack/opt/spack/cgns\n</code></pre></li> </ol>"},{"location":"dev-guide/developers_doc/#creation-of-an-optional-module","title":"Creation of an optional module","text":"<p>Once a component is created, we use a github workflow in order to structure the code development. We also intensively use unit tests to valid our codes and also to perform code coverage when we merge developments.</p> <p>The creation of a new GMDS component requires to follow the guideline given below.</p>"},{"location":"dev-guide/developers_doc/#how-to-writeupdate-a-cmakeliststxt-file-for-a-module","title":"How to write/update a CMakeLists.txt file for a module","text":"<p>Be careful, each time you add a new header file in the inc subdirectory or a source file in the src subdirectory, a reference to this file must be added in the CMakeLists.txt* file.</p>"},{"location":"dev-guide/developers_doc/#how-to-create-a-new-module","title":"How to create a new module","text":"<p>GMDS is structured as a set of libraries, each library being defined in a module. We follow the strict rule of \"one module gives one library\". In order to define a new module, and so library you have to follow the next series of actions. Let us consider that we want to define a new module named xxx</p> <ol> <li> <p>At the root directory of gmds, add a directory, named by your module name (always start with a small letter). Let us call it xxx;</p> </li> <li> <p>At the root directory of gmds, open the file CMakeLists.txt and add the following command in the section entitle OPTIONAL COMPONENTS</p> </li> </ol> <p><pre><code>GMDS_ADD_COMPONENT(\n        XXX                               # cmake variable\n        xxx                               # src subdirectory name\n        GMDSXxx                           # name of the generated library\n        \"description of the component\"  # description\n        ON                                  # is activated\n        ON                                 # must be covered\n)\n</code></pre> GMDS_ADD_COMPONENT is a CMake macro for GMDS. - The first parameter of the macro is the CMake variable that will be used for this component. - The source code of the component must be in the subdirectory given as the second parameter. - The third parameter is the name given at the component library when it will be installed. In the project and everywhere in another \"CMakeLists.txt\" file, the library will be accessible via the marco ${LIB_GMDS_XXX}$ - The fourth parameter is a Boolean flag indicating that the component must be built (ON) or not (OFF) - The fifth parameter is also a Boolean flag used to know if the module must be covered by the code coverage procedure that we use when a \"push\"-like command is performed.</p> <ol> <li> <p>Get into the xxx subdirectory and create 3 subdirectories named inc, src and tst and a CMakeLists.txt file. In the inc subdirectory create a subdirectory gmds that includes subdirectory xxx* to achieve the following structure xxx/inc/gmds/xxx/**</p> </li> <li> <p>Fill the *CMakeLists.txt\" file as follows:</p> </li> </ol> <pre><code>#==============================================================================\n# LIBRARY DEFINITION (SOURCE FILES)\n#==============================================================================\n# Explicitly used the name given in this preamble\nset(GMDS_LIB ${LIB_GMDS_XXX})\nset(GMDS_LIB_PREFIX gmds/xxx)\n\nset(GMDS_INC\n        inc/gmds/xxx/Class1.h\n        inc/gmds/xxx/Class2.h\n        )\nset(GMDS_SRC\n        src/Class1.cpp\n        src/Class2.cpp\n        )\n#==============================================================================\nadd_library(${GMDS_LIB} ${GMDS_INC} ${GMDS_SRC})\n#==============================================================================\n# TARGET DEFINITION\n#==============================================================================\ninclude(GNUInstallDirs)\n#LIBRARY TO INSTALL\ntarget_link_libraries(${GMDS_LIB} PUBLIC\n        ${LIB_GMDS_CAD}\n        ${LIB_GMDS_IG})\n\n#==============================================================================\n# NOTHING TO UPDATE BELOW\n#==============================================================================\n\ntarget_compile_features(${GMDS_LIB} PUBLIC cxx_std_14)\n\n# INCLUDE TO INSTALL\ntarget_include_directories(${GMDS_LIB} PUBLIC\n        $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc&gt;\n        $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include&gt;\n        )\nset_target_properties(${GMDS_LIB} PROPERTIES PUBLIC_HEADER \"${GMDS_INC}\")\n\ninstall(TARGETS ${GMDS_LIB}\n        EXPORT GMDS_SUITE\n        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${GMDS_LIB_PREFIX}\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds)\n\n#==============================================================================\nif(WITH_TEST)\n#    add_subdirectory(tst)\nendif(WITH_TEST)\n#==============================================================================\n</code></pre> <p>This file deserves a few comments: - You must set the two first variables using the name of your component (XXX) and the name of the subdirectory (xxx). - Each time you create a new class, the corresponding header and src files must be added to the lists GMDS_INC and GMDS_SRC respectively. - Note that the inc subdirectory is always structured with two subdirectories, i.e. inc/gmds/xxx/ for getting a homogeneous way of accessing to gmds header files. - The command target_link_libraries(${GMDS_LIB} PUBLIC ....) is very important. It is where you give the dependency of your module to other GDMS module or to external libraries. - The remainder of the CMakefiles.txt should not be edited. It is used to generate libraries and to define the install procedure</p>"},{"location":"dev-guide/developers_doc/#how-to-create-an-executable-in-a-gmds-module","title":"How to create an executable in a GMDS module","text":"<p>A GMDS module is associated to a library, but an executable can also be produced. Considering the module XXX, you can do so it by adding the next lines at the end  of the CMakeLists.txt file. </p> <pre><code>#==============================================================================\n# EXECUTABLE\n#==============================================================================\nadd_executable(xxx src/main.cpp)\ntarget_link_libraries(xxx PRIVATE ${GMDS_LIB})\ntarget_compile_features(xxx PUBLIC cxx_std_14)\ninstall(TARGETS xxx)\n</code></pre>"},{"location":"dev-guide/unit_test/","title":"Test directory structure","text":"<p>Every gmds component has a tst directory that contains test suites to perform. All our tests are based on Google test. The classical structure of a test directory is : <pre><code>AFirstTestSuite.h\nASeconTestSuite.h\nCMakeLists.txt\nmain.cpp\n</code></pre></p>"},{"location":"dev-guide/unit_test/#process-to-test-a-new-feature","title":"Process to test a new feature","text":"<p>Each time you need to test a new class and methods you want to develop, the process is the following one. 1. Create a class C by declaring it in inc/C.h and provides all the method definitions in src/C.cpp. At this stage, method definition are either empty methods or methods that throw an exception. 2. Create in tst a new class for testing C behaviour. By convention, you will note it CTestSuite.h. You will then addd test method using google test. As an example below, we test some getters ans setters of the math::Point class. Only one test method is given but the test class (here PointClass) can contain as much as test method you want. TEST and ASSERT_NEAR are macros provided by the Google Test framework.</p> <p><pre><code>/*----------------------------------------------------------------------------*/\n#ifndef GMDS_POINT_TESTSUITE_H\n#define GMDS_POINT_TESTSUITE_H\n/*----------------------------------------------------------------------------*/\n#include \"gtest/gtest.h\"\n#include &lt;gmds/math/Point.h&gt;\n/*----------------------------------------------------------------------------*/\nTEST(PointClass, Setter)\n{\n    gmds::math::Point p(1,2,3);\n    gmds::TCoord z = p.Z();\n    ASSERT_NEAR(p.X(), 1, 1e-6);\n    ASSERT_NEAR(p.Y(), 2, 1e-6);\n    ASSERT_NEAR(z, 3, 1e-6);\n}\n/*----------------------------------------------------------------------------*/\n#endif //GMDS_POINT_TESTSUITE_H\n/*----------------------------------------------------------------------------*/\n</code></pre> 3. Once created the file must be added in the CMakeLists.txt to be used in the compilation stage. Get into this file and only modify the list of header/source files used to build the executable test.</p> <p><pre><code>add_executable(GMDS_MATH_TEST\n        ChartTestSuite.h\n        CrossTestSuite.h\n        Cross2DTestSuite.h\n        MathTestSuite.h\n        PointTestSuite.h\n        QuaternionTestSuite.h\n        OrientationTestSuite.h\n        ... CTestSuite.h ...\n        main_test.cpp)\n</code></pre> If the directory tst is empty and you are the first one to create a unit test suite for a component. Just copy and paste a CMakeLists.txt file of another component test directory and change the executable name and likely the list of dependencies (in the CMake macro target_link_libraries).</p> <ol> <li>It remains a last step, which is to modify (or create) the main_test.cpp file, which looks like <pre><code>/*----------------------------------------------------------------------------*/\n#include &lt;gtest/gtest.h&gt;\n/*----------------------------------------------------------------------------*/\n// Files containing the different test suites to launch\n\n#include &lt;ChartTestSuite.h&gt;\n#include &lt;Cross2DTestSuite.h&gt;\n#include &lt;CrossTestSuite.h&gt;\n#include &lt;OrientationTestSuite.h&gt;\n/*----------------------------------------------------------------------------*/\nint main(int argc, char ** argv) {\n  ::testing::InitGoogleTest(&amp;argc, argv);\n  return RUN_ALL_TESTS();\n}\n/*----------------------------------------------------------------------------*/\n</code></pre> You need to include the new file you just created in the list of files included  at the beginning of this file;</li> </ol>"},{"location":"python-binding/pygmds/","title":"Python binding for gmds","text":"<p>Python binding is a 2023 feature of gmds to help writing high-level meshing algorithms. We mainly focus on machine learning and blocking subject right now.</p>"},{"location":"python-binding/pygmds/#structure","title":"Structure","text":"<p>The python binding provide a python module gmds and several submodules relative to gmds components:</p> <ul> <li>blocking - provides blocking operations.</li> <li>geometry - provides access to the geometrical kernel to queries faceted geometric model to write meshing algorithms.</li> <li>math - gives access to some basic mathematical concepts handled by gmds.</li> <li>mesh - provides meshing operations including vtk IO.</li> </ul>"},{"location":"python-binding/pygmds/#how-to-use-the-gmds-python-api","title":"How to use the gmds Python API?","text":"<p>The python module packaging is not up-to-date right now. We advise you to apply the following procedure on Linux platform.</p> <pre><code>#==========================================\n#First we clone spack and change his way for installing\ngit clone --depth=1 -b v0.20.3  https://github.com/spack/spack.git\nsed -i 's#\"{architecture}/{compiler.name}-{compiler.version}/{name}-{version}-{hash}\"#\"{name}\"#g' spack/etc/spack/defaults/config.yaml\nsource ./spack/share/spack/setup-env.sh\n#==========================================\n#mandatory if you have already used back on your computer\nspack clean -m\n#==========================================\ngit clone --depth=1 https://github.com/LIHPC-Computational-Geometry/spack_recipes_meshing.git\nspack repo add ./spack_recipes_meshing/meshing\nspack repo add ./spack_recipes_meshing/meshing_supersede\nspack compiler find\nspack external find cmake\n#==========================================\nspack install --no-checksum gmds@main+python+blocking~cgns\n#==========================================\nexport PYTHONPATH=spack/opt/spack/gmds/lib:$PYTHONPATH\nspack load gmds\n</code></pre> <p>Our procedure relies on spack, a package manager for supercomputers, Linux and macOS. With the previous set of commands, you are going to build a complete gmds environment that you can use in your Python code.</p>"},{"location":"user-guide/blocking/","title":"Blocking module","text":"<p>This module provides a data structure for a blocking representation. It relies on the n-G-map model and we specifically use the 3-G-Map implementation  provided by CGAL library (see https://doc.cgal.org/latest/Generalized_map/index.html).</p> <p>The development of this module is in progress. The final purpose is to provide a robust and reliable curved block  structure for hex blocking mesh representation. </p>"},{"location":"user-guide/blocking/#compilation-and-installation","title":"Compilation and installation","text":"<p>This module is built using the global <code>CMakeLists.txt</code>of gmds. An extra option (<code>WITH_CGNS</code>) is provided to allow CGNS export. It requires then to install the adequate CGNS library. </p> <p>This procedure must be described in details and the spack recipes must be updated.</p>"},{"location":"user-guide/blocking/#main-concepts","title":"Main concepts","text":"<p>The blocking structure is described in  the class CurvedBlocking. It relies on the 3-G-map model and provide several blocking queries and gives access to the underlying 3-G-map.</p> <p>The CurvedBlockingClassifierprovides the first prototype to classify a block structure onto a geometrical model. </p>"},{"location":"user-guide/blocking/#blocking-classification","title":"Blocking classification","text":"<p>All blocking structures are classified. It means that we need to build a blocking structure from a geometrical model. Nodes, edges and faces are classified on geometrical entities.</p> <p>In order to automatically classify cells, we use two parameters:  - a maximal distance MD for projecting a node. If the distance to any geometrical cell is greater than MD, then the node is not moved and classified. - A snapping distance SD that is used during a correction stage. After projecting a node on a curve or a surface, we check if this node could not be snapped onto a geometrical point with a distance lower to SD.</p> <p>Remark: This two parameters are use-case specific and should be automatically computed in the future.</p>"},{"location":"user-guide/blocking/#geometrical-and-topological-operations","title":"Geometrical and topological operations","text":"<p>It is possible to move a node with the method <code>CurvedBlocking::move_node</code>. This methods takes classification into account: - A node classified onto a geometrical point cannot move; - A node classified onto a geometrical curve will be moved to the expected location then projected onto the curve; - The same behavior occurs for nodes classified on geometrical surfaces.</p> <p>Two operations are available to remove a block (<code>CurvedBlocking::remove_block</code>), or split a series of blocks along an  edge (<code>CurvedBlocking::cut_sheet</code>). In the second case, the obtained blocks remain glued each to others.</p>"},{"location":"user-guide/cad/","title":"CAD module","text":"<p>This module provides cad interface representation for meshing algorithms.</p>"},{"location":"user-guide/cadfac/","title":"CADFAC module","text":"<p>This module provides a faceted implementation of the  cad  interface representation for meshing algorithms.</p>"},{"location":"user-guide/elg3d/","title":"Elgmorphing module","text":"<p>This module provides algoritmes to morph a mesh</p>"},{"location":"user-guide/frame/","title":"Frame module","text":""},{"location":"user-guide/frame3d/","title":"Frame3d module","text":""},{"location":"user-guide/geodhoneycomb/","title":"GeodHoneyComb module","text":"<p>This module provides algorithsm to generate hexahedral meshes for spherical shapes using a pattern based on honeycombs.</p> <p>The usage is depicted by the unit tests given in unit test files (see geodHoneyComb/tst/GeodHoneyCombTestSuite.h for examples). In the following code snippet, we use the class GeodHexMesher to generate a sphere with 3 layers of of cells. The sphere is centered at origin and is radius values 1. We use a uniform discretization for all  layers including the central one which contains pyramidal cells in the center.</p> <pre><code>//creation of the meshing algorithm\nGeodHexMesher ghm;\nghm.setCenter(math::Point(0,0,0));\nghm.setRadius(1);\n\n//layers are created with a uniform discretization for all of them\nmath::DiscretizationScheme1DUniform d(math::Point(0,0,0), math::Point(1,0,0), 10);\nauto layer0 = std::make_pair(0., &amp;d); //inner radius being at 0 means we will have a whole sphere\nauto layer1 = std::make_pair(0.5, &amp;d);\nauto layer2 = std::make_pair(0.8,&amp;d);\nauto layer3 = std::make_pair(0.9,&amp;d);\nstd::map&lt;double, math::DiscretizationScheme1D*&gt; layers;\nlayers.insert(layer1);\nlayers.insert(layer2);\nlayers.insert(layer3);\nlayers.insert(layer0);\nghm.setLayerData(layers);\n\n// execution of the algorithm\nGeodHexMesher::OpResult res = ghm.execute();\n\n//if the algorithm succeeded, we can access to the produced mesh\nif(res == GeodHexMesher::GEOD_SUCCESS)\n    std::unique_ptr&lt;Mesh&gt; m = ghm.getMesh();\n</code></pre> <p>We get the following resulting mesh with one color per layer.</p> <p></p>"},{"location":"user-guide/hybridmeshadapt/","title":"HybridMeshAdapt module","text":"<p>This module proposes an algorithm to adapt a tetrahedral mesh into an hybrid one using frame fiels and metrics.</p> <p>To achieve a sufficient level of performances, a mesh data structure dedicated to simplicial meshes is used in this component instead of those proposed by the ig and kmds modules.</p>"},{"location":"user-guide/hybridmeshadapt/#stage-1","title":"Stage 1","text":"<p>The first executable to use is main_METRIC_FF_PointGeneration : The frontal process is subdividide in 3 step     The node generation on the curve, the surface and the volume. The function nodesSpreading is used to spread the node     on the surface and then on the volume. The result of this algorithm is a mesh containing the node and the related hexaedron.</p> <pre><code>* metricXYZ_functors is a vector of function containing the metric informations\n* frameXYZ_functors is a vector of function containing the frame informations (if the function return a nul size vector, the frame field of the mesh is used.)\n\nOnce The two vector have been specified the constructor MetricFFPointgeneration p(&amp;simplexMesh, name_final_mesh, interpolation_factor) is called,\ninterpolation_factor is the value of the interpolation between the frame and the metric orientation. The frontal process will generate node in the direction of the\nframe field when interpolation_factor tend to 1. If interpolation_factor tend to 0 the node will follow the directions of the metric directions, (see the function MetricFFPointgeneration::metricInterpolationWithDistorsion(const Eigen::Matrix3d  &amp; metric, const Eigen::Matrix3d  &amp; frameField)).\n</code></pre>"},{"location":"user-guide/hybridmeshadapt/#stage-2","title":"Stage 2","text":"<p>Once the previous process is done, we call main_HEX_GENERATION with the initial mesh and the result mesh of the main_METRIC_FF_PointGeneration.     * First, we perform a Delaunay node insertion, then the node that has not been inserted are inserted using only the simplex containing the current node (l:131-247)     * Second, we remove the initial node of the mesh, this step contribute to build the shell of the hexaedron. (l:267-329)     * Third, we build the remaining edge between the inserted node (in order to build the shell of the future hexaedron). (l:332-368)     * To finish we force the faces of the futur hexaedrons. If the 6 faces exist the hexaedron is built, and the tetraedron forming the hex are marked in order to not be built       in the final mesh (l:378-454)</p>"},{"location":"user-guide/hybridmeshadapt/#stage-3","title":"Stage 3","text":"<p>The last step will build the hexaedron from the remaining tetradron, the executable main_TET2HEX is called to perform this.</p>"},{"location":"user-guide/ig/","title":"IG module","text":"<p>IG, for incidence graph, is the main and legacy mesh data structure provided in gmds.</p> <p>The ig module provides basic data structure for handling meshes based on an \"Incident Graph\" representation (which explains why it is called ig). Traditionally a graph G=(V,A) is made of vertices and arcs that connect vertices. For giving a model to represent mesh data structures, we use such a graph model, where vertices are the dimensions of cells explicitly stored in the data structure. In other words, vertices are denoted: 1. R for regions or 3-dimensional cells (for short 3-cells), 2. F for faces or 2-cells, 3. E for edges or 1-cells, 4. N for nodes or 0-cells.</p> <p>Connections, ie. graph arcs, are cell connections and are written X2Y with X and Y that are R, F, E or N. For instance F2N means that we store the connection from faces to nodes, while N2R indicates that we have to store the connection from nodes to regions. A MeshModel object can be built on this graph structure and given to a Mesh object to initialise it. <pre><code>MeshModel model(DIM3|F|E|N|F2N|E2N|N2F);\nMesh m(model);\n</code></pre></p>"},{"location":"user-guide/ig/#block-structures-meshes","title":"Block-structures meshes","text":"<p>In order to handle block structures meshes, we complete the IG representation with a \"quasi-structured\" or \"block-structured\" view built on the traditional IG model (see the class Mesh)</p> <p>The blocking2D structure is a full unstructured mesh made of hex blocks, quad faces, edges and nodes. Block, faces and edges only exist at the macro level, or block level. Nodes are block corners  but also inner-block nodes. Each node knows it is a corner-block (block level) or an inner-node using the node on-node variable called \"embedding\". An embedding is a Cell::Data that corresponds to the block entity the node is embedded in. It is made of a dim and an id.  It can be on a corner-block(0), face-block(2), edge-block (1) and inner-block(3). Each block as a grid structure. It must be so possible to use bracket notation [i+,j-1] to acces to a neighbor nodes. This  type of traversal should be possible almost everywhere and allows the user to traverse several blocks in a row. The only issue is when you meet singular corners (ie with valence not equal to 4).</p>"},{"location":"user-guide/igalgo/","title":"IGAlgo module","text":"<p>This module provides some basic algorithms for the incidence graph (ig) data structure:</p> <ul> <li>Most important algorithms are relative to retrieving and building some boundary informations: boundaryOperator, boundaryExtractor.</li> <li>The GridBuilder class provides algoriths to build 2D and 3D structured grids for unit testing purposes mainly.</li> <li>The THexBuilder create a hexahedral mesh by splitting each tet of an input tetrahedral mesh.</li> <li>The MeshQualityCompute go through all the mesh cells and assign variables depending on a set of selected quality criteria</li> <li>The SurfaceReorient class reorient surface mesh (in 2D and 3D) in order to have all faces oriented in the same direction. If the mesh is split in different connex components, the orientation between different components can be different. In practice, the orientation is consistent in 2D.</li> </ul>"},{"location":"user-guide/io/","title":"IO module","text":"<p>This module propose mechanisms that allows us to import/export the mesh data structure.  This mechanism is not optimized for performances.</p>"},{"location":"user-guide/kmds/","title":"KMDS module","text":"<p>In order to write concurrent meshing algorithms that could benefit from manycore architectures, we derived the incidence graph using the Kokkos library.</p>"},{"location":"user-guide/math/","title":"Math module","text":"<p>This modules gather usual mathematics objects and concepts we use and work with for writing our meshing algorithms.</p>"},{"location":"user-guide/padding/","title":"Padding module","text":"<p>This module simply contains some padding algorithms. Origin of this work wast to understand and reproduce the work proposed in Selective Padding for Polycube-Based Hexahedral Meshing</p>"},{"location":"user-guide/polyblock/","title":"Polyblock module","text":"<p>Polycube-maps-based approaches are one of the promising technology that can be used to generate full hex mesh. This  module gather the works we've done on this subject.</p>"},{"location":"user-guide/quality/","title":"Quality module","text":"<p>This module gathers quality measure for mesh cells. Proposed quality measure are based on the choice done in the Verdict Geometric Quality Library: - Stimpson, C. J., Ernst, C. D., Knupp, P., P\u00e9bay, P. P., &amp; Thompson, D. (2007). The Verdict library reference manual. Sandia National Laboratories Technical Report, 9. (see https://digital.library.unt.edu/ark:/67531/metadc880826/)</p>"},{"location":"user-guide/sheet/","title":"Sheet module description","text":"<p>In this module, we provide the usual operations that can  be safely performed on quad or hex mesh. By safely, we means that the mesh remains a full quad, respectively hex mesh after performing a sheet operation.</p> <p>We provide the 3 basic operations, which are: - Sheet selection. Giving 2 nodes, or an edge, it returns  the set of cells that belongs to the corresponding sheet. - Sheet collapse. Giving 2 nodes, or an edge, it removes  the corresponding sheet from the mesh. - Sheet pillow. Giving a path of edges or a convex set of cells, it inserts a sheet inside the mesh.</p>"},{"location":"user-guide/sheet/#requirements","title":"Requirements","text":"<p>Sheet collapse and pillow are operations that modify the mesh. They are quite easy to implement if you only consider the mesh structure but taking geometric classification  makes it more tricky to handle.</p> <p>Geometric classification requires to handle a few special  cases where faces (in 3D) and edges (in 2D) are required along the mesh boundary. It means that we restrict our implementation to mesh where: - in 2D, boundary edges must be defined in the mesh and connection E2N at least.  We do not use the N2E connectivity because it enforces all the mesh nodes to store an indirection to a potential list of adjacent edges. - in 23D, boundary faces and edges must be defined in the mesh and connections F2N and E2N at least</p>"},{"location":"user-guide/singgraphbuild/","title":"SingGraphBuild module","text":"<p>Once a 2D frame field generated, the purpose of the current module is to extract the topological structure fo this frame, i.e. a singularity graph. </p>"},{"location":"user-guide/smoothy/","title":"Smoothy module","text":"<p>The aim of this module is to gather some smoothing algorithms. Mesh smoothing algorithms consist in moving mesh nodes without changing mesh topology. We classify smoothing algorithms in two categories:  1. Those that are aware of the geometric classification. They are the less academic ones, but those used in practice. Most of the time they provide functions to smooth nodes on curves, surfaces and inside the volumes.  2. The other ones that smooth all the nodes excepted a bunch of ones that are locked to their positions. They derive from academic papers that deal with such low constraints.</p> <p>Every algorithm is defined in a gmds class whose the naming indicates the type of mesh it acts on. More specifically, a class name that ends with 2C or 3C respectively means that the algorithm acts on a 2D classified mesh (2C) or a 3D classifed mesh (3C). If the postfix is 2UC or 3UC, it means that the algorithms acts on an unclassified mesh (UC).</p>"},{"location":"user-guide/smoothy/#how-to-use-a-smoothing-algorithm","title":"How to use a smoothing algorithm?","text":"<p>Like other meshing algorithms in gmds, smoothing algorithms provided an <code>isValid</code> method to check if the mesh we work on is adapted to the algorithm and a <code>smooth</code> method to perform the algorithm. As an example, let us consider the simple 2D laplacian smoother without geometric classification (see the function <code>grid_2D_smooth_UC</code> in the test file LaplacianSmootherTestSuite.h). To call this  smoothing algorithm, we have a next series of instruction to write:</p> <pre><code>smoothy::LaplacianSmoother2UC smoother(&amp;m);\nASSERT_TRUE(smoother.isValid());\nsmoother.setNbIterations(1);\n...\nsmoother.setNodes(to_move);\n...\nsmoother.smooth();\n</code></pre> <p>First, we initialize the smoother object as an instance of <code>LaplacianSmoother2UC</code>. We check if the mesh <code>m</code> is valid for the algorithm with <code>smoother.isValid()</code>and then we indicate the number of iterations (<code>setNBIterations</code>) of the algorithm and the nodes to smooth (<code>setNodes</code>). The <code>setNodes</code> method takes as parameters a vector of node ids.</p> <p>For an algorithm that use the geometric classification, we also need to provide the linker object as usual. See  for instance the test method <code>tet_in_cube</code> in the file LaplacianSmootherTestSuite.h.</p>"},{"location":"user-guide/smoothy/#elliptic-smoothing","title":"Elliptic smoothing","text":"<p>The elliptic smoother provides an implementation of the ACM TOG paper Foldover-free maps in 50 lines of code (https://dl.acm.org/doi/abs/10.1145/3450626.3459847). This algoriths allows to smooth a 2D mesh with some nodes that are locked. Example of usages are given in the unit tests.</p>"},{"location":"user-guide/users_doc/","title":"How to use gmds","text":"<p>GMDS is a set of C++ libraries that can be used to develop meshing algorithms. It requires features of C++14.</p> <p>The build system is based on CMAKE (https://cmake.org) and unit tests are performed using google tests and google benchmarks.</p> <p>In order to perform some linear algebra operations, we rely onto the Eigen library (http://eigen.tuxfamily.org/index.php?title=Main_Page) that provides us matrices, vectors, numerical solvers, and related algorithms.</p>"},{"location":"user-guide/users_doc/#how-to-compile-install-and-link-against-gmds","title":"How to compile, install and link against GMDS","text":"<p>GMDS build system is CMake. In order to build GMDS, the direct way consists in the following stages</p>"},{"location":"user-guide/users_doc/#cloning-the-git-repository","title":"Cloning the git repository","text":"<ul> <li>Extracting GMDS from the gitub repository by cloning it (best option if you want to contribute afterward) or copying it. Let us assume that it is extracted in /home/gmds by cloning the github repository. <pre><code>cd /home/\ngit clone https://github.com/LIHPC-Computational-Geometry/gmds.git\n</code></pre></li> </ul>"},{"location":"user-guide/users_doc/#build-directory-for-cmake-purpose","title":"Build directory for CMake purpose","text":"<p>In the /home/$ directory, we create a directory where the project will be built. Let us name it build*. We will then get into this subdirectory to prepare the project to be built using CMake. <pre><code>cd /home/\nmkdir build\ncd build\ncmake ../gmds/ \n</code></pre></p>"},{"location":"user-guide/users_doc/#compilation-toolchain","title":"Compilation toolchain","text":"<p>Depending on the options you provide to the cmake command line, you will get different way of building it. If you chose to create a Makefile, you will then have to build and (optionally) to install it <pre><code>make -j4\nmake install\n</code></pre></p>"},{"location":"user-guide/users_doc/#example-of-toy-code-that-uses-gmds","title":"Example of toy code that uses gmds","text":""},{"location":"user-guide/users_doc/#gmds-project-structure","title":"GMDS Project structure","text":"<p>GMDS project is split into a set of \"modules\", which are connected each to others. Each module is structured as follows:</p> <ul> <li>One subdirectory inc, which contains all the headers files of the module;</li> <li>One subdirectory src, which contains all the source files of the module;</li> <li>One subdirectory tst, which contains a set of unit tests written using google test. The aim of this tst subdirectory is both to (1) dynamically ensure the right and expected behaviour of the module and (2) provide some usage examples for other developers.</li> <li>A file named CMakeLists.txt used by CMAKE to build the module.</li> </ul> <p>GMDS modules are of two kinds : core ones and optional ones</p>"},{"location":"user-guide/users_doc/#core-modules","title":"Core modules","text":"<p>Core modules gather generic data structures, math classes, utils, basic algorithms and some Read and Write interfaces to be implemented. We have:</p> <ul> <li>cad: contains all the data structure and main query operations required for writing meshing algorithms.</li> <li>math: mathematical simple concepts that are implemented and reused in many algorithms.</li> <li>io: read and write classes with an interface definition to be implemented for new mesh data structure you would like to read and write.</li> <li>ig: serial generic mesh data structure based on an incidence-graph representation.</li> </ul>"},{"location":"user-guide/users_doc/#optional-modules","title":"Optional modules","text":"<p>Optional modules can be activated using the cmake option ENABLE_XXX where XXX is the module name. For instance for building the FRAME module, you have to add the option -DENABLE_FRAME=true: <pre><code>cmake ../gmds/ -DENABLE_FRAME=true\n</code></pre> Available modules are : - frame - frame3d - kmds: concurrent thread-based mesh data structure. \"k\" means \"Kokkos\" the underlying framework we used for managing concurrency. - Elg3D - hybridMeshAdapt - singGraphBuild - ...</p> <p>The lists of all the available optional modules can be seen in the root CMakeLists.txt file or using the ccmake command instead of the cmake command.</p>"},{"location":"user-guide/utils/","title":"Utils module","text":"<p>This module gathers utilitary classes that are used in all the gmds components.</p>"}]}