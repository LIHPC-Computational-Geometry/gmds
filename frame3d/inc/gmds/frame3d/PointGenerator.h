/*----------------------------------------------------------------------------*/
#ifndef SH_POINT_GENERATOR_H_
#define SH_POINT_GENERATOR_H_
/*----------------------------------------------------------------------------*/
// STL File Headers
#include <vector>
#include <set>
#include <map>
/*----------------------------------------------------------------------------*/
// GMDS File Headers
#include <gmds/ig/Mesh.h>
#include <gmds/math/Chart.h>
#include <gmds/math/SHarmonicL4.h>
/*----------------------------------------------------------------------------*/
#include <gmds/frame3d/Params.h>
#include "LIB_GMDS_FRAME_3D_export.h"
/*----------------------------------------------------------------------------*/
namespace gmds{
/*----------------------------------------------------------------------------*/
/** @class  PointGenerator
 *  @brief  Starting from a frame field, this algorithm generate a set of points
 *          that will be used for creating a quasi-structured mesh afterward (
            mostly made of quadrilaterals and hexahedrals)
 */
class LIB_GMDS_FRAME_3D_API PointGenerator{
    
public:
    /*------------------------------------------------------------------------*/
    /** \brief Constructor.
     *
     * \param[in] AMesh    the mesh where we work on
     * \param[in] ANormal  normal for each boundary node
     * \param[in] AMarks   Boolean marks
     * \param[in] ASpacing the expected spacing between generated points.
     * \param[in] ACurl    used curl value for the algorithm
     */
    PointGenerator(gmds::Mesh* AMesh,
                   const ParamsGlobal& AParamGl,
                   std::map<gmds::TCellID, gmds::math::Vector3d>& ANormal,
                   const ParamsMark& AMarks,
                   const double ASpacing=1.0,
                   const double ACurl=0.35);
    
    
    /*------------------------------------------------------------------------*/
    /** \brief Function to be called for generating the frame field
     */
    void execute();
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the generated points
     *
     * \return the points generated by the algorithm
     */
    const std::vector<gmds::math::Point>& points() const {
        return m_points;
    }
    /*------------------------------------------------------------------------*/
    /** \brief Access to the generated charts
     *
     * \return the charts generated by the algorithm
     */
    const std::vector<gmds::math::Chart>& charts() const {
        return m_charts;
    }
    /*------------------------------------------------------------------------*/
    /** \brief Access to the generated point data
     *
     * \return the mesh data associated to each generated point
     */
    const std::vector<gmds::Cell::Data>& pointMeshData() const {
        return m_point_data;
    }
    /*------------------------------------------------------------------------*/
    /** \brief Access to the generated type of points
     *
     * \return the type points generated by the algorithm
     */
    const std::vector<int>& pointTypes() const {
        return m_point_types;
    }
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the generated classification of points
     *
     * \return the geometric classification of points generated by the algorithm
     */
    const std::vector<int>& pointClassification() const {
        return m_point_classification;
    }
    
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the spacing computed locally to each generated point
     *
     * \return the spacing for each point generated by the algorithm
     */
    const std::vector<double>& pointSpacing() const {
        return m_point_spacing;
    }
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the point curve numbering
     */
    const std::vector<int>& pointCurveNumbering() const {
        return m_point_curves;
    }
    
    
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the point surface numbering
     */
    const std::vector<int>& pointSurfaceNumbering() const {
        return m_point_surfaces;
    }
    
    
    /*------------------------------------------------------------------------*/
    /** \brief For a point generated onto a geometric vertex, we get the curve
     *         it belongs to too*/
    const std::map<int,std::vector<int> >& pointVertexToCurves() const {
        return m_point_vertex_to_curves;
    }
    
    /*------------------------------------------------------------------------*/
    /** \brief Access to the point surface numbering
     */
    const std::map<int,gmds::math::Vector3d>& pointSurfaceNormal() const {
        return m_point_surface_normals;
    }
    
    void writeOutput();

    
protected:
    /*------------------------------------------------------------------------*/
    /** \brief Structure used to orient edges for Rij computation
     */
    struct OrientedEdge{
        /** mesh edge this is relative too*/
        gmds::Edge edge;
        /** Starting point of the oriented edge*/
        gmds::Node first;
        /** End point of the oriented edge*/
        gmds::Node second;
        /*--------------------------------------------------------------*/
        /** \brief Default constructor (for STL container purpose only)
         */
        OrientedEdge();
        /*--------------------------------------------------------------*/
        /** \brief Constructor from an edge and two nodes
         */
        OrientedEdge(gmds::Edge& e,
                     gmds::Node& f,
                     gmds::Node& s);
        
        /*--------------------------------------------------------------*/
        /** \brief Constructor from an edge only
         */
        OrientedEdge(gmds::Edge& e);
        
        /*--------------------------------------------------------------*/
        /** \brief Returns true if this->first and this->second are resp.
         *         the first and second node of this->edge, false otherwise
         */
        bool isWellOriented();
    };
    
    /*------------------------------------------------------------------------*/
    /** \brief Build the oriented edges of face \p AF in such a way that the 
     *         edge i connects node i to i+1 (modulo the number of corners)
     *
     * \param[in] AF a face
     *
     * \return an ordered set of oriented edges
     */
    std::vector<OrientedEdge> getOrientedEdge(const gmds::Face& AF);
    
    
    /*------------------------------------------------------------------------*/
    /** \brief Compute the g_ij value for oriented edge \p AEdge
     *
     * \param[in] AEdge an oriented edge
     *
     * \return a 3D vector
     */
    gmds::math::Vector3d computeGij(OrientedEdge& AEdge) ;
    
    /*------------------------------------------------------------------------*/
    /** \brief Compute the c_ij corrective term for oriented edge \p AEdge
     *
     * \param[in] AEdge an oriented edge
     *
     * \return a 3D vector
     */
    gmds::math::Vector3d computeCij(OrientedEdge& AEdge) ;
 
    /*------------------------------------------------------------------------*/
    /** \brief Compute the the g_ij terme for the oriented edge defined by \p
     *         AEdge and going from node \p AFrom to node \p ATo
     *
     * \param[in] AEdge an  edge
     * \param[in] AFrom the node we execute from
     * \param[in] ATo   the node we execute to
     *
     * \param the value Gij computed for this oriented edge
     */
    gmds::math::Vector3d computeGijWithCurl(gmds::Edge& AEdge,
                                            gmds::Node& AFrom,
                                            gmds::Node& ATo);

    /*------------------------------------------------------------------------*/
    /** \brief Returns all the regions sharing a node with \p ATet
     *
     * \param[in] ATet the tetrahedral element we start from
     *
     * \return the regions that share at least a node with \p ATet
     */
    std::vector<gmds::Region> getTetSharingOneNode(const gmds::Region& ATet);
    
    
    void computeCurlCorrection();
    /*------------------------------------------------------------------------*/
    /** \brief build the local id map to have a continous numbering of the nodes
     *        involved in this algorithm
     */
    void buildLocalIDs();
    
    /*------------------------------------------------------------------------*/
    /** \brief Nodes located on the boundary are constrained by normal 
     *         preserving
     */
    void setBoundaryConstraint();
    
    /*------------------------------------------------------------------------*/
    /** \brief Init the least-square system to be solved
     */
    void initSystem();
    /*------------------------------------------------------------------------*/
    /** \brief Build the least-square system to be solved
     */
    void buildSystem();
    /*------------------------------------------------------------------------*/
    /** \brief Solve the least-square system to be solved
     */
    void solveSystem();
    /*------------------------------------------------------------------------*/
    /** \brief Extract the parametrization solution after the system resolution
     */
    void getUiSolution();
    /*------------------------------------------------------------------------*/
    /** \brief Clean up the memory used by the least-square system solver
     */
    void cleanSystem();
    
    /*------------------------------------------------------------------------*/
    /** \brief Extract the set of points we need for building our mesh
     * \param[in/out] APts all the extracted points
     */
    void extractPoints();
    
    /*------------------------------------------------------------------------*/
    /** \brief Extract a set of points and charts for tetrahedral element 
     *         \p ATet and add them to \p APnts and \p ACharts respectively
     * 
     * \param[in]     ATet     the tetrahedral we extract point from
     * \param[in/out] APnts    the set of points we add the extracted points
     *                         for ATet
     * \param[in/out] ACharts  the set of charts we add the extracted charts
     *                         for \p ATet. Value \p ACharts[i] is the chart
     *                         interpolated for point \p APnts[i]
     * \param[in/out] AData     the set of mesh data we add
     *                         for \p ATet. Value \p ACharts[i] is the chart
     *                         interpolated for point \p APnts[i]
     * \param[in/out] AType    the type of each extracted point for \p ATet.
     * \param[in/out] AClass   the geom. classification of each extracted point
     *                         for \p ATet.
     * \param[in/out] ASPacing the spacing interpolated for each extracted point
     *                         from \p ATet.
     * \param[in/out] ASurf    the surf id associated to for each extracted point
     *                         located on the boundary of \p ATet .
     *
     * \return the number of attempts to extract points that failed due to 
     *         numerical issues
     */
    int extractPoints(const gmds::Region&                   ATet,
                      std::vector<gmds::math::Point>&       APnts,
                      std::vector<gmds::math::Chart>&       ACharts,
                      std::vector<gmds::Cell::Data>&        AData,
                      std::vector<int>&                     ATypes,
                      std::vector<int>&                     AClass,
                      std::vector<double>&                  ASpacing,
                      std::vector<int>&                     ASurf,
                      std::vector<int>&                     ACurv,
                      std::map<int,gmds::math::Vector3d>&   ASurfNormal);
    

    /*------------------------------------------------------------------------*/
    /** \brief Indicates if the face \p AF is singular. It returns 0 if it is
     *         not, 1 if it is a PGP singularity and 2 if it is a frame field
     *         singularity.
     *
     * \param[in] AF a face we want to check the singularity type
     *
     * \return an integer indicating the singularity type of \p AF (0:not,
     *         1:PGP, 2:FF)
     */
    int getSingularityType(const gmds::Face& AF);
    
    /*------------------------------------------------------------------------*/
    /** \brief Indicates if the face \p AF is PGP singular.
     *
     * \param[in] AF a face we want to check
     *
     * \return true if it is PGP singular, false otherwise
     */
    bool isPGPSingular(const gmds::Face& AF);
    
    /*------------------------------------------------------------------------*/
    /** \brief Indicates if the face \p AF is FF singular.
     *
     * \param[in] AF a face we want to check
     *
     * \return true if it is FF singular, false otherwise
     */
    bool isFFSingular(const gmds::Face& AF);
    
    /*------------------------------------------------------------------------*/
    /** \brief Returns the singularity type of a region \p AR
     *
     * \param[in] AR a region we want to check the singularity type
     *
     * \return an integer indicating the singularity type of \p AF (0:not,
     *         1: 1 PGP-face, 2: 2 PGP-face, 3: 3 PGP-face, 4: 4 PGP-face, 
     *         5: 1 FF-face, 6: 2-FF-face, 7: 3 FF-face, 8: 4 FF-face)
     */
    int getSingularityType(const gmds::Region& AR);
    

    /*------------------------------------------------------------------------*/
    /** \brief Transport a point from the parameter space to the physical one.
     *         This transport is done locally to the linear map associated to a
     *         simplex, here we compute the barycentric coordinates of the
     *         tetrahedral element \p ATetParam living in the
     *         parametric space is transported to the tet \p ATetPhys living in
     *         the physical space.
     *
     * \param[in]  APntParam the input point in the parametric space
     * \param[in]  ATetParam the tetrahedron in parametric space,
     *             defined by four points
     
     * \param[out] ACoord the barycentric coordinate of \p AP in \p ATet if
     *             \p AP is in \p ATet and there is no numerical computation
     *             issue.
     *
     * \return true if \p APntParam lives in ATetParam and can be transported,
     *         false otherwise
     */
    bool computeBarycenter(const gmds::math::Point& APntParam,
                           const gmds::math::Point* ATetParam,
                           gmds::math::Vector4d& ACoord) const;
    /*------------------------------------------------------------------------*/
    /** \brief Compute the Rij mapping transporting the frame defined in \p AI
               into the frame defined in \p AJ
     *
     * \param[in]  AI a first node id
     * \param[in]  AJ a second node id
     * \return a mapping transporting the frame defined in \p AI into the 
     *         frame defined in \p AJ
     */
    gmds::math::Chart::Mapping getRij(const gmds::TCellID AI,
                                      const gmds::TCellID AJ) const;
    /*------------------------------------------------------------------------*/
    /**  \brief Compute the Rij mapping transporting the frame defined in \p AI
     *          into the frame defined in \p AJ
     *
     * \param[in]  AI a first node
     * \param[in]  AJ a second node
     * \return a mapping transporting the frame defined in \p AI into the
     *         frame defined in \p AJ
     */
    gmds::math::Chart::Mapping getRij(const gmds::Node& AI,
                                      const gmds::Node& AJ) const;
    
    /*------------------------------------------------------------------------*/
    /**  \brief This method align the Tij value \p AToBeAligned onto the Tij
     *          value \p ARef, knowing that a geometrical deviation must be
     *          taken into account
     *
     * \param[in/out] AToBeAligned   a Tij value to align
     * \param[in]     ARef           the reference Tij value
     * \param[in]     AGeomDeviation the known geometric deviation between the
     *                               two first parameters
     */
    void alignTij(gmds::math::Vector3d& AToBeAligned,
                  const gmds::math::Vector3d& ARef,
                  const gmds::math::Vector3d& AGeomDeviation);
    
    /*------------------------------------------------------------------------*/
    /** \brief Check if a face \p AF is defined from nodes \p AN1, \p AN2 and
     *        \p AN3
     *
     * \param[in]  AF a mesh face
     * \param[in]  AN1 first node index
     * \param[in]  AN2 second node index
     * \param[in]  AN3 third node index
     * \return true if the nodes of \p AF are \p AN1, \p AN2, \p AN3,
     *        false otherwise
     */
    bool hasNodes(const gmds::Face& AF,
                  const gmds::TCellID AN1,
                  const gmds::TCellID AN2,
                  const gmds::TCellID AN3);
    
    bool isOnCurve(const gmds::Node& ANode);
    gmds::math::Vector3d getOutputNormal(gmds::Face& AFace, gmds::Region& ARegion);
    gmds::math::Vector3d getOutputNormalOfABoundaryFace(gmds::Face& AFace);

    /*------------------------------------------------------------------------*/
    /** \brief Compute the classification of a point with barycentric coord.
     *         \p ACoord into a tet whose nodes \p AN, edges \p AE and faces
     *         are given in a specific and known order.
     *
     * \details This function must so not be used out of this context/
     *
     * \param[in]  ACoord  barycentric coordinate of a point in a tet T
     * \param[in]  AN      nodes of T
     * \param[in]  AE      edges of T
     * \param[in]  AF      faces of T
     * \param[out] ASID    surface id if the point is classified on a surface
     * \param[out] ACID    curve id if the point is classified on a curve
     * \param[out] ANID    node id if the point is classified on a geometric vertex
     * \param[out] ANormal outward normal if the point is classified on a surface
     * \param[out] APnt    the point which is modified by projection onto the right
     *                     face
     *
     * \return 0 if the point is located onto a geometric point, 1 for a
     *         curve, 2 for a surface and 3 for a volume.
     */
    int computeClassification(const gmds::math::Vector4d&    ACoord,
                              const std::vector<gmds::Node>& AN,
                              const std::vector<gmds::Edge>& AE,
                              const std::vector<gmds::Face>& AF,
                              int&                           ASID,
                              int&                           ACID,
                              gmds::TCellID&                 ANID,
                              gmds::math::Vector3d&          ANormal);
    
    /*------------------------------------------------------------------------*/
    /** \brief Build ...
     *
     */
    void buildANNTree(const std::vector<gmds::math::Point>& APnts,
                      std::vector<gmds::math::Chart>&       ACharts,
                      std::vector<gmds::Cell::Data>&        AMeshData,
                      std::vector<int>&                     ATypes,
                      std::vector<int>&                     AClass,
                      std::vector<int>&                     ACurv,
                      std::vector<int>&                     ASurf,
                      std::map<int,gmds::math::Vector3d>&   ANormal,
                      std::vector<double>&                  ASpacing,
                      std::vector<std::vector<int> >&       AOutPnts);
    
protected:
    
    /** the mesh we work on */
    gmds::Mesh* m_mesh;
    
    ParamsGlobal m_param_gl;
    
    /** rotation field previously computed for each node. */
    gmds::Variable<gmds::math::AxisAngleRotation>* m_rotation_field;
    /** face color previously computed for each face. */
    gmds::Variable<int>* m_surface_face_color;
    /** node color previously computed for each node. */
    gmds::Variable<int>* m_surface_node_color;
    /** node color previously computed for each node. */
    gmds::Variable<int>* m_curve_edge_color;
    /** node color previously computed for each node. */
    gmds::Variable<int>* m_curve_node_color;
    
    /** Defines a normal constraint alignment for boundary nodes
     * we work on */
    std::map<gmds::TCellID, gmds::math::Vector3d> m_normal;
    
    /** Boolean marks */
    ParamsMark m_bm;
    
    /** the relative spacing distance between generated points */
    double m_spacing;
    
    double m_curl;

    /** nb unknowns of the least-square system to be solved */
    int m_nb_unknowns;
    
    
    /** Give a local id for the nodes we work on in this algorithm */
    std::map<gmds::TCellID, int> m_id;
    
    /** Give a local id for the edges we work on in this algorithm */
    std::map<gmds::TCellID, int> m_edge_id;
    
    std::map<gmds::TCellID, gmds::math::Vector3d > m_Ui;
    /** correction factor along each edge. The global id of the edge is
     * used as the key */
    std::map<gmds::TCellID, gmds::math::Vector3d > m_corr;

    /** For a boundary node indicate which of its chart vector is
     * aligned with the surface normal N. A vector (0,1,0) indicates
     * that the second chart vector is aligned with N*/
    std::map<gmds::TCellID, gmds::math::Vector3d > m_bnd_constraint;
    
    /** generated points */
    std::vector<gmds::math::Point> m_points;
    /** for each point give the cell it belong to */
    std::vector<gmds::Cell::Data> m_point_data;
    /** generated charts */
    std::vector<gmds::math::Chart> m_charts;
    
    /** type of generated points
     *(0-stable, 1-in PGP tet, 2 in FF tet)*/
    std::vector<int> m_point_types;
   
    /** geometric classification of generated points
     *(0-point, 1-curve, 2-surface, 3-volume*/
    std::vector<int> m_point_classification;
    
    /** spacing computed locally to the point*/
    std::vector<double> m_point_spacing;
    
    /** For a point generated onto a surface, it gives a surface ID
     *  according to the face and node variables called
     *  BND_SURFACE_COLOR. Otherwise it returns -1*/
    std::vector<int> m_point_surfaces;
    
    /** For a point generated onto a curve, it gives a curve ID
     *  according to the edge and node variables called
     *  BND_CURVE_COLOR. Otherwise it returns -1*/
    std::vector<int> m_point_curves;
    
    
    /* for a point generated on a geometric vertex, we store the
     * adjacent curve ids */
    std::map<int,std::vector<int> > m_point_vertex_to_curves;
    /** For a point generated on a geometric vertex, we keep in 
     *  the corresponding node in the background tet mesh */
    std::map<int, gmds::TCellID> m_point_vertex_to_node;

    std::map<int,gmds::math::Vector3d> m_point_surface_normals;

};

    /*----------------------------------------------------------------------------*/
}
/*----------------------------------------------------------------------------*/
#endif /* SH_POINT_GENERATOR_H_ */
/*----------------------------------------------------------------------------*/
