<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gmds: gmds::PointConnectionBuilder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gmds
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegmds.html">gmds</a></li><li class="navelem"><a class="el" href="classgmds_1_1_point_connection_builder.html">PointConnectionBuilder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgmds_1_1_point_connection_builder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gmds::PointConnectionBuilder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_this.html">This</a> class provides an algorithm to connect a set of points that are defined on tetrahedral mesh where a frame field lives on. <a class="el" href="class_a.html">A</a> frame is defined for each point to connect. The output is a set of "connection" information indicating for each frame field direction where a point is connected to.  
 <a href="classgmds_1_1_point_connection_builder.html#details">More...</a></p>

<p><code>#include &lt;PointConnectionBuilder.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Structure to store hex corner data for each input point. <a class="el" href="class_a.html">A</a> corner data is made of the index of the current point (p), the index of the 3 points helping to form the corner (adj). Each "edge" [p,adj[i]] is geometrically defined by vec[i].  <a href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Structure to store an oriented edge made of the index of the first and second points and the chart data used in the first point to select this <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html" title="Local Structure to store an oriented edge made of the index of the first and second points and the ch...">OrientedEdge</a>. <a class="el" href="class_a.html">A</a> chart data (-1,-1) means that the selected end point finally do not correspond to a chart alignment (will happen for boundary points for instance)  <a href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47c383c790b65e001f98f2a1bc97d8eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a47c383c790b65e001f98f2a1bc97d8eb">PointConnectionBuilder</a> (<a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *AMesh, const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &gt; &amp;APnts, const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_chart.html">gmds::math::Chart</a> &gt; &amp;ACharts, const std::vector&lt; <a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a> &gt; &amp;AData, const std::vector&lt; int &gt; &amp;ATypes, const std::vector&lt; int &gt; &amp;AClass, const std::vector&lt; int &gt; &amp;ACurv, const std::vector&lt; int &gt; &amp;ASurf, const std::map&lt; int, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &gt; &amp;ANormal)</td></tr>
<tr class="memdesc:a47c383c790b65e001f98f2a1bc97d8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classgmds_1_1_point_connection_builder.html#a47c383c790b65e001f98f2a1bc97d8eb">More...</a><br /></td></tr>
<tr class="separator:a47c383c790b65e001f98f2a1bc97d8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993df0fb1e07ca63408fe38a9adcd7f5"><td class="memItemLeft" align="right" valign="top"><a id="a993df0fb1e07ca63408fe38a9adcd7f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a993df0fb1e07ca63408fe38a9adcd7f5">execute</a> ()</td></tr>
<tr class="memdesc:a993df0fb1e07ca63408fe38a9adcd7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called for generating the mesh. <br /></td></tr>
<tr class="separator:a993df0fb1e07ca63408fe38a9adcd7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8ab6e0ce0321f708c4a0f93b1796f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a41f8ab6e0ce0321f708c4a0f93b1796f">getEdges</a> (std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;AEdges)</td></tr>
<tr class="memdesc:a41f8ab6e0ce0321f708c4a0f93b1796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edge info. Once performed the algorithm, we can acces to edges which are defined by the point index int the vector of point given when constructing *this.  <a href="classgmds_1_1_point_connection_builder.html#a41f8ab6e0ce0321f708c4a0f93b1796f">More...</a><br /></td></tr>
<tr class="separator:a41f8ab6e0ce0321f708c4a0f93b1796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071566c6f0be30a48a14bf8148f4a681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a071566c6f0be30a48a14bf8148f4a681">getHexes</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;AHexes)</td></tr>
<tr class="memdesc:a071566c6f0be30a48a14bf8148f4a681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns hexa info. Once performed the algorithm, we can acces to all the hexahedral cells that can be created.  <a href="classgmds_1_1_point_connection_builder.html#a071566c6f0be30a48a14bf8148f4a681">More...</a><br /></td></tr>
<tr class="separator:a071566c6f0be30a48a14bf8148f4a681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc05a09ad448fb1f6ab31afd6c8feb46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#acc05a09ad448fb1f6ab31afd6c8feb46">mesh</a> () const</td></tr>
<tr class="memdesc:acc05a09ad448fb1f6ab31afd6c8feb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the generated mesh.  <a href="classgmds_1_1_point_connection_builder.html#acc05a09ad448fb1f6ab31afd6c8feb46">More...</a><br /></td></tr>
<tr class="separator:acc05a09ad448fb1f6ab31afd6c8feb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af992b27f8c1d092596750db7c5dd7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a6af992b27f8c1d092596750db7c5dd7e">setDebugInfo</a> (const bool &amp;AWithDebug, const std::string &amp;AOutputDir=&quot;.&quot;)</td></tr>
<tr class="memdesc:a6af992b27f8c1d092596750db7c5dd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the debug info flag used during the algorithm execution.  <a href="classgmds_1_1_point_connection_builder.html#a6af992b27f8c1d092596750db7c5dd7e">More...</a><br /></td></tr>
<tr class="separator:a6af992b27f8c1d092596750db7c5dd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577b501453d8f7d65ebbb7adb0e292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#af577b501453d8f7d65ebbb7adb0e292f">setSpacing</a> (const double ASize=1.0)</td></tr>
<tr class="memdesc:af577b501453d8f7d65ebbb7adb0e292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In order to minimise some spatial research a spacing parameter is used in the code. Its setting is not obvious, so we can change it by this way for experiments.  <a href="classgmds_1_1_point_connection_builder.html#af577b501453d8f7d65ebbb7adb0e292f">More...</a><br /></td></tr>
<tr class="separator:af577b501453d8f7d65ebbb7adb0e292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a626f8270b41c00e13fd2ad238e8eddf5"><td class="memItemLeft" align="right" valign="top"><a id="a626f8270b41c00e13fd2ad238e8eddf5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EPointClassification</b> { <b>ON_VERTEX</b> =0, 
<b>ON_CURVE</b> =1, 
<b>ON_SURFACE</b> =2, 
<b>IN_VOLUME</b> =3
 }</td></tr>
<tr class="separator:a626f8270b41c00e13fd2ad238e8eddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396185b9a2a355c9527823141d8a73a2"><td class="memItemLeft" align="right" valign="top"><a id="a396185b9a2a355c9527823141d8a73a2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EPointType</b> { <b>REGULAR</b> =0, 
<b>PARAM_SING</b> =1, 
<b>FRAME_SING</b> =2
 }</td></tr>
<tr class="separator:a396185b9a2a355c9527823141d8a73a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acbbc2985ba2bed75acd01cef25a0b8ed"><td class="memItemLeft" align="right" valign="top"><a id="acbbc2985ba2bed75acd01cef25a0b8ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#acbbc2985ba2bed75acd01cef25a0b8ed">createDistanceFilter</a> ()</td></tr>
<tr class="memdesc:acbbc2985ba2bed75acd01cef25a0b8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build for each point a list of close points to be compared with during edge creation. <br /></td></tr>
<tr class="separator:acbbc2985ba2bed75acd01cef25a0b8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c13a857019b296c7514487a473a383"><td class="memItemLeft" align="right" valign="top"><a id="a17c13a857019b296c7514487a473a383"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a17c13a857019b296c7514487a473a383">computeMeshAssociation</a> ()</td></tr>
<tr class="memdesc:a17c13a857019b296c7514487a473a383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate each point to a mesh cell. <br /></td></tr>
<tr class="separator:a17c13a857019b296c7514487a473a383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27d9a5f8682db0afbc032cf087dbc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a9c27d9a5f8682db0afbc032cf087dbc7">buildOrientedEdges</a> (std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;AEdges)</td></tr>
<tr class="memdesc:a9c27d9a5f8682db0afbc032cf087dbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build oriented edges from each point to its neighbor points in a local point of view. <code>AEdges</code>[i] contains all the oriented edges coming from point i.  <a href="classgmds_1_1_point_connection_builder.html#a9c27d9a5f8682db0afbc032cf087dbc7">More...</a><br /></td></tr>
<tr class="separator:a9c27d9a5f8682db0afbc032cf087dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad641888e3b7f0e995c06ef591e72581a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ad641888e3b7f0e995c06ef591e72581a">buildOrientedEdgesInVolume</a> (const int APntID, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> AVec[][2], <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> APnt[][2], int AIndex[][2], bool AFound[][2])</td></tr>
<tr class="memdesc:ad641888e3b7f0e995c06ef591e72581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build oriented edges for the point <code>APntId</code> which is located into the volume. The input point is necessary REGULAR.  <a href="classgmds_1_1_point_connection_builder.html#ad641888e3b7f0e995c06ef591e72581a">More...</a><br /></td></tr>
<tr class="separator:ad641888e3b7f0e995c06ef591e72581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03c4006fb36ef8db7d458a6ceea918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#aeb03c4006fb36ef8db7d458a6ceea918">buildOrientedEdgesOnSurface</a> (const int APntID, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> AVec[][2], <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> APnt[][2], int AIndex[][2], bool AFound[][2])</td></tr>
<tr class="memdesc:aeb03c4006fb36ef8db7d458a6ceea918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build oriented edges for the point <code>APntId</code> which is located onto a surface. The input point is necessary REGULAR.  <a href="classgmds_1_1_point_connection_builder.html#aeb03c4006fb36ef8db7d458a6ceea918">More...</a><br /></td></tr>
<tr class="separator:aeb03c4006fb36ef8db7d458a6ceea918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3474dbc2ec9c74d6fac66d40055f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a2b3474dbc2ec9c74d6fac66d40055f19">buildOrientedEdgesOnCurve</a> (const int APntID, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> AVec[][2], <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> APnt[][2], int AIndex[][2], bool AFound[][2])</td></tr>
<tr class="memdesc:a2b3474dbc2ec9c74d6fac66d40055f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build oriented edges for the point <code>APntId</code> which is located on a curve. The input point is necessary REGULAR.  <a href="classgmds_1_1_point_connection_builder.html#a2b3474dbc2ec9c74d6fac66d40055f19">More...</a><br /></td></tr>
<tr class="separator:a2b3474dbc2ec9c74d6fac66d40055f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845626ef9aed530e4a6ee815708bd5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a845626ef9aed530e4a6ee815708bd5e6">filterPointsForBuildingOrientedEdge</a> (const std::vector&lt; int &gt; &amp;AID, const std::vector&lt; double &gt; &amp;ADot, const std::vector&lt; double &gt; &amp;ADist)</td></tr>
<tr class="memdesc:a845626ef9aed530e4a6ee815708bd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select among different point which is the bes aligned and/or at a good distance to build an oriented edge.  <a href="classgmds_1_1_point_connection_builder.html#a845626ef9aed530e4a6ee815708bd5e6">More...</a><br /></td></tr>
<tr class="separator:a845626ef9aed530e4a6ee815708bd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3545fba16fad4af95e44b0425066c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a6c3545fba16fad4af95e44b0425066c5">buildEdges</a> (std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;AInEdges, std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;AOutEdges)</td></tr>
<tr class="memdesc:a6c3545fba16fad4af95e44b0425066c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct oriented edges to get a onsistent structure.  <a href="classgmds_1_1_point_connection_builder.html#a6c3545fba16fad4af95e44b0425066c5">More...</a><br /></td></tr>
<tr class="separator:a6c3545fba16fad4af95e44b0425066c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bbb14131b81459b53edfad85ebb787"><td class="memItemLeft" align="right" valign="top"><a id="ad8bbb14131b81459b53edfad85ebb787"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ad8bbb14131b81459b53edfad85ebb787">computeVolumePointFrom</a> (const int APntIndex, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AV, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt)</td></tr>
<tr class="memdesc:ad8bbb14131b81459b53edfad85ebb787"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:ad8bbb14131b81459b53edfad85ebb787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f173b391e9e4f6a1f9d15e68561172e"><td class="memItemLeft" align="right" valign="top"><a id="a1f173b391e9e4f6a1f9d15e68561172e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a1f173b391e9e4f6a1f9d15e68561172e">computeSurfacePointFrom</a> (const int APntIndex, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AV, <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt)</td></tr>
<tr class="memdesc:a1f173b391e9e4f6a1f9d15e68561172e"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a1f173b391e9e4f6a1f9d15e68561172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d74fd4429eeea40a67ff1de46b063e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a9d74fd4429eeea40a67ff1de46b063e3">isIn</a> (const int AFrom, const int ATo, const std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &amp;AEdgeSet, <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &amp;AOutEdge) const</td></tr>
<tr class="memdesc:a9d74fd4429eeea40a67ff1de46b063e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an oriented edge going from <code>AFrom</code> to <code>ATo</code> exists in <code>AEdgeSet</code>.  <a href="classgmds_1_1_point_connection_builder.html#a9d74fd4429eeea40a67ff1de46b063e3">More...</a><br /></td></tr>
<tr class="separator:a9d74fd4429eeea40a67ff1de46b063e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63681d4e2fbcbae7800e52814c5734b9"><td class="memItemLeft" align="right" valign="top"><a id="a63681d4e2fbcbae7800e52814c5734b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a63681d4e2fbcbae7800e52814c5734b9">buildHexCorners</a> (std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;AEdges)</td></tr>
<tr class="memdesc:a63681d4e2fbcbae7800e52814c5734b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the m_hc_mapping attribute for each stable points. Such a point should be the corner of 1, 2, 4 or 8 hexahedral elts depending if it is classified on a geometric vertex, curve, surface or volume. <br /></td></tr>
<tr class="separator:a63681d4e2fbcbae7800e52814c5734b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee319efc42499eef57efc6f33b53cf18"><td class="memItemLeft" align="right" valign="top"><a id="aee319efc42499eef57efc6f33b53cf18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#aee319efc42499eef57efc6f33b53cf18">buildHexahedral</a> ()</td></tr>
<tr class="memdesc:aee319efc42499eef57efc6f33b53cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build hexahedral elements. <br /></td></tr>
<tr class="separator:aee319efc42499eef57efc6f33b53cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cedaf441016cb1d325a7146809748a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a44cedaf441016cb1d325a7146809748a">findCommonPoints</a> (const int AFrom, const int AI, const int AJ)</td></tr>
<tr class="memdesc:a44cedaf441016cb1d325a7146809748a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find among the free corners of <code>AI</code> and <code>AJ</code> an end point which is different of <code>AFrom</code> but both in a free corner of <code>AI</code> and <code>AJ</code>.  <a href="classgmds_1_1_point_connection_builder.html#a44cedaf441016cb1d325a7146809748a">More...</a><br /></td></tr>
<tr class="separator:a44cedaf441016cb1d325a7146809748a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571643627eb6fcc72ac3ad961f29c42e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a571643627eb6fcc72ac3ad961f29c42e">findCommmonLastCorner</a> (const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;ACorner1, const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;ACorner2, const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;ACorner3, <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;ACornerOut)</td></tr>
<tr class="memdesc:a571643627eb6fcc72ac3ad961f29c42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from three corner points, it returns the free corner of the point that apperas in all of them and which is pointed to all of their origins.  <a href="classgmds_1_1_point_connection_builder.html#a571643627eb6fcc72ac3ad961f29c42e">More...</a><br /></td></tr>
<tr class="separator:a571643627eb6fcc72ac3ad961f29c42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b71de4fba2163e83feca68bb272e9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#af1b71de4fba2163e83feca68bb272e9b">getCorner</a> (const int AOrigin, const int AI, const int AJ, const int AK, <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;AOut)</td></tr>
<tr class="memdesc:af1b71de4fba2163e83feca68bb272e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looking at all the corners defined for origin point <code>AOrigin</code>, it returs the corner corresponding to (<code>AOrigin</code>, <code>AI</code>, <code>AJ</code>, <code>AK</code>) if it exist.  <a href="classgmds_1_1_point_connection_builder.html#af1b71de4fba2163e83feca68bb272e9b">More...</a><br /></td></tr>
<tr class="separator:af1b71de4fba2163e83feca68bb272e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa33f5876fd8fee5bae298e9f52206"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a2eaa33f5876fd8fee5bae298e9f52206">isCorner</a> (const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;AC, const int AOrigin, const int AI, const int AJ, const int AK)</td></tr>
<tr class="memdesc:a2eaa33f5876fd8fee5bae298e9f52206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>AC</code> is a corner corresponding to (<code>AOrigin</code>, <code>AI</code>, <code>AJ</code>, <code>AK</code>)  <a href="classgmds_1_1_point_connection_builder.html#a2eaa33f5876fd8fee5bae298e9f52206">More...</a><br /></td></tr>
<tr class="separator:a2eaa33f5876fd8fee5bae298e9f52206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095642ed1f38d55f861e6c5fd09162ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a095642ed1f38d55f861e6c5fd09162ba">findFreeCorners</a> (const std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &gt; &amp;AIn, const int AFrom, std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &gt; &amp;AOut)</td></tr>
<tr class="memdesc:a095642ed1f38d55f861e6c5fd09162ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find among the corners in <code>AIn</code> those having <code>AFrom</code> as an adjacent point.  <a href="classgmds_1_1_point_connection_builder.html#a095642ed1f38d55f861e6c5fd09162ba">More...</a><br /></td></tr>
<tr class="separator:a095642ed1f38d55f861e6c5fd09162ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc68481dc20f70a0abc35b8659a112"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">PointConnectionBuilder::HexCorner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a57bc68481dc20f70a0abc35b8659a112">findFreeCorners</a> (const std::vector&lt; int &gt; &amp;AOrigin, const int AI, const int AJ)</td></tr>
<tr class="memdesc:a57bc68481dc20f70a0abc35b8659a112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free corners of <code>AOrigin</code> with <code>AI</code> and <code>AI</code> as end points.  <a href="classgmds_1_1_point_connection_builder.html#a57bc68481dc20f70a0abc35b8659a112">More...</a><br /></td></tr>
<tr class="separator:a57bc68481dc20f70a0abc35b8659a112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7eb67183295eb81d3846c033ccc374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a2d7eb67183295eb81d3846c033ccc374">addCorner</a> (const int AIndex, const int AIndex1, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AV1, const int AIndex2, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AV2, const int AIndex3, const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;AV3)</td></tr>
<tr class="memdesc:a2d7eb67183295eb81d3846c033ccc374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a corner data to the point with index <code>AIndex</code>.  <a href="classgmds_1_1_point_connection_builder.html#a2d7eb67183295eb81d3846c033ccc374">More...</a><br /></td></tr>
<tr class="separator:a2d7eb67183295eb81d3846c033ccc374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543a7fbd297314c7463917ea9bbad919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a543a7fbd297314c7463917ea9bbad919">buildCornersAsSolidAngles</a> (const int AOrigin, std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &amp;AEdges)</td></tr>
<tr class="memdesc:a543a7fbd297314c7463917ea9bbad919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build all the corners associated to <code>AOrigin</code> by considering existing edges <code>AEdges</code>. <a class="el" href="class_this.html">This</a> construction is based on geom. criteria.  <a href="classgmds_1_1_point_connection_builder.html#a543a7fbd297314c7463917ea9bbad919">More...</a><br /></td></tr>
<tr class="separator:a543a7fbd297314c7463917ea9bbad919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129088b60882358b66bcc568484729df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a129088b60882358b66bcc568484729df">computeMeshAssociation</a> (const int AID)</td></tr>
<tr class="memdesc:a129088b60882358b66bcc568484729df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mesh association for point AID. <a class="el" href="class_this.html">This</a> computation is performed knowing how the point is classified (0,1,2 or 3) and the id of the curve.  <a href="classgmds_1_1_point_connection_builder.html#a129088b60882358b66bcc568484729df">More...</a><br /></td></tr>
<tr class="separator:a129088b60882358b66bcc568484729df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd03511e94509e9b48591b9f79c97f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#acd03511e94509e9b48591b9f79c97f8d">getRegionContaining</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ATetID)</td></tr>
<tr class="memdesc:acd03511e94509e9b48591b9f79c97f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the region information (dim=3, id) of the region that contains <code>APnt</code>.  <a href="classgmds_1_1_point_connection_builder.html#acd03511e94509e9b48591b9f79c97f8d">More...</a><br /></td></tr>
<tr class="separator:acd03511e94509e9b48591b9f79c97f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e32be1786994dd3733533588a586de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a83e32be1786994dd3733533588a586de">getBoundaryFaceContaining</a> (<a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ATetID, const double ADistance, const int ASurfID)</td></tr>
<tr class="memdesc:a83e32be1786994dd3733533588a586de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face information (dim=2, id) of the boundary face that contains <code>APnt</code>.  <a href="classgmds_1_1_point_connection_builder.html#a83e32be1786994dd3733533588a586de">More...</a><br /></td></tr>
<tr class="separator:a83e32be1786994dd3733533588a586de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91538713117f4480342ad19172557c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a91538713117f4480342ad19172557c8f">getBoundaryEdgeContaining</a> (<a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;APnt, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ATetID, const double ADistance, const int ACurvID)</td></tr>
<tr class="memdesc:a91538713117f4480342ad19172557c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the edge information (dim=2, id) of the boundary edge that contains <code>APnt</code>.  <a href="classgmds_1_1_point_connection_builder.html#a91538713117f4480342ad19172557c8f">More...</a><br /></td></tr>
<tr class="separator:a91538713117f4480342ad19172557c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf0ff05d26b04d29c7fc05f3c2be3e"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a54bf0ff05d26b04d29c7fc05f3c2be3e">getCloseRegionsFrom</a> (const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AFromPnt, const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AFromTet, const double AEpsilon)</td></tr>
<tr class="memdesc:a54bf0ff05d26b04d29c7fc05f3c2be3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_this.html">This</a> function give the list of region ids such that generated points associated to those regions could be at a distance less or equal to <code>AEps</code> from <code>APnt</code>.  <a href="classgmds_1_1_point_connection_builder.html#a54bf0ff05d26b04d29c7fc05f3c2be3e">More...</a><br /></td></tr>
<tr class="separator:a54bf0ff05d26b04d29c7fc05f3c2be3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a45472d7a6c4ff236bd920b2322b046"><td class="memItemLeft" align="right" valign="top"><a id="a9a45472d7a6c4ff236bd920b2322b046"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getOppositeBndFace</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ANodeID, const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AR, <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AOut)</td></tr>
<tr class="separator:a9a45472d7a6c4ff236bd920b2322b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e3e6f1c339a2c5a980563a077a33a5"><td class="memItemLeft" align="right" valign="top"><a id="a42e3e6f1c339a2c5a980563a077a33a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateTetMesh</b> ()</td></tr>
<tr class="separator:a42e3e6f1c339a2c5a980563a077a33a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75073888c76ea2ac7f2e165716831dd7"><td class="memItemLeft" align="right" valign="top"><a id="a75073888c76ea2ac7f2e165716831dd7"></a>
<a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getOutputNormal</b> (<a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFace, <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;ARegion)</td></tr>
<tr class="separator:a75073888c76ea2ac7f2e165716831dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75b2319df5ef37a6d068a891ebdbfd9"><td class="memItemLeft" align="right" valign="top"><a id="af75b2319df5ef37a6d068a891ebdbfd9"></a>
<a class="el" href="classgmds_1_1_face.html">gmds::Face</a>&#160;</td><td class="memItemRight" valign="bottom"><b>closestFace</b> (<a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AP, int ASurfID)</td></tr>
<tr class="separator:af75b2319df5ef37a6d068a891ebdbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18551c1d59a989b66f776b47fece8e9"><td class="memItemLeft" align="right" valign="top"><a id="af18551c1d59a989b66f776b47fece8e9"></a>
<a class="el" href="classgmds_1_1_edge.html">gmds::Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>closestEdge</b> (<a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;AP, int ACurvID)</td></tr>
<tr class="separator:af18551c1d59a989b66f776b47fece8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c03f6cc6b3b58305a8b95495b6e1b52"><td class="memItemLeft" align="right" valign="top"><a id="a0c03f6cc6b3b58305a8b95495b6e1b52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeInput</b> ()</td></tr>
<tr class="separator:a0c03f6cc6b3b58305a8b95495b6e1b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39960ea21586f261e4900477886294f"><td class="memItemLeft" align="right" valign="top"><a id="ac39960ea21586f261e4900477886294f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeHexes</b> ()</td></tr>
<tr class="separator:ac39960ea21586f261e4900477886294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467d37d6697b9198c17946c066a24cb5"><td class="memItemLeft" align="right" valign="top"><a id="a467d37d6697b9198c17946c066a24cb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeEdges</b> (std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;AInEdges, const std::string &amp;AFileName)</td></tr>
<tr class="separator:a467d37d6697b9198c17946c066a24cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac30b7eb059bc4cf657a5c832f5656f8f"><td class="memItemLeft" align="right" valign="top"><a id="ac30b7eb059bc4cf657a5c832f5656f8f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>getOppositeRegion</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ANodeID, const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AR, <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AOut)</td></tr>
<tr class="separator:ac30b7eb059bc4cf657a5c832f5656f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a1881dfa548484712b7b2f414a48b"><td class="memItemLeft" align="right" valign="top"><a id="adb6a1881dfa548484712b7b2f414a48b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>getOppositeFace</b> (const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ANodeID, const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AR, <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AOut)</td></tr>
<tr class="separator:adb6a1881dfa548484712b7b2f414a48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28fe0fce68dc730f8657f6b0ec4f2b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgmds_1_1_face.html">gmds::Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ab28fe0fce68dc730f8657f6b0ec4f2b8">getFace</a> (const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;AFrom, const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;AR, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ANI, const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> ANJ)</td></tr>
<tr class="memdesc:ab28fe0fce68dc730f8657f6b0ec4f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face of <code>AR</code> sharing nodes <code>ANI</code> and <code>ANJ</code> with face <code>AFrom</code>.  <a href="classgmds_1_1_point_connection_builder.html#ab28fe0fce68dc730f8657f6b0ec4f2b8">More...</a><br /></td></tr>
<tr class="separator:ab28fe0fce68dc730f8657f6b0ec4f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9b706a15b551992d7d6345d60068aa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a4e9b706a15b551992d7d6345d60068aa">isIn</a> (<a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> AI, const std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;AV)</td></tr>
<tr class="memdesc:a4e9b706a15b551992d7d6345d60068aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>AI</code> is in <code>AV</code>.  <a href="classgmds_1_1_point_connection_builder.html#a4e9b706a15b551992d7d6345d60068aa">More...</a><br /></td></tr>
<tr class="separator:a4e9b706a15b551992d7d6345d60068aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d56906d2d963e75f4e1e5191549b28"><td class="memItemLeft" align="right" valign="top"><a id="a96d56906d2d963e75f4e1e5191549b28"></a>
static std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getFaces</b> (const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;ANI, const <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &amp;ANJ)</td></tr>
<tr class="separator:a96d56906d2d963e75f4e1e5191549b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a980b55c144bbe1b1908918ce4cadc79d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a980b55c144bbe1b1908918ce4cadc79d">m_mesh</a></td></tr>
<tr class="separator:a980b55c144bbe1b1908918ce4cadc79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0e2a89355449589b1b2927a3678d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ad3b0e2a89355449589b1b2927a3678d4">m_pnt</a></td></tr>
<tr class="separator:ad3b0e2a89355449589b1b2927a3678d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5c3c71a9edbf70d2b374558ab35b0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_chart.html">gmds::math::Chart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a7ef5c3c71a9edbf70d2b374558ab35b0">m_chart</a></td></tr>
<tr class="separator:a7ef5c3c71a9edbf70d2b374558ab35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842e352961ae548e04c493134e3a54d8"><td class="memItemLeft" align="right" valign="top"><a id="a842e352961ae548e04c493134e3a54d8"></a>
std::vector&lt; <a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_mesh_data</b></td></tr>
<tr class="separator:a842e352961ae548e04c493134e3a54d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e9a3fc675952236aed50ba0baeba44"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ae5e9a3fc675952236aed50ba0baeba44">m_type</a></td></tr>
<tr class="separator:ae5e9a3fc675952236aed50ba0baeba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50ff6d084918e1e518cfa2c83b3212c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#ae50ff6d084918e1e518cfa2c83b3212c">m_classification</a></td></tr>
<tr class="separator:ae50ff6d084918e1e518cfa2c83b3212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554174d798b8202f5d5ca2a09d768c62"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a554174d798b8202f5d5ca2a09d768c62">m_curve</a></td></tr>
<tr class="separator:a554174d798b8202f5d5ca2a09d768c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193a6bda568d44b4a1f45fa8236313c1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a193a6bda568d44b4a1f45fa8236313c1">m_surface</a></td></tr>
<tr class="separator:a193a6bda568d44b4a1f45fa8236313c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701672bae3cbeacbdfebb7486d66e3e"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a9701672bae3cbeacbdfebb7486d66e3e">m_normal</a></td></tr>
<tr class="separator:a9701672bae3cbeacbdfebb7486d66e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35a5c731d77f59a538149583903cf4f"><td class="memItemLeft" align="right" valign="top"><a id="ad35a5c731d77f59a538149583903cf4f"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_used</b></td></tr>
<tr class="separator:ad35a5c731d77f59a538149583903cf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7847be1a31f69d2296592dc1b92a4c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a7847be1a31f69d2296592dc1b92a4c57">m_hexes</a></td></tr>
<tr class="separator:a7847be1a31f69d2296592dc1b92a4c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71abe0dddad74b2ad2c0b6193e630f26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a71abe0dddad74b2ad2c0b6193e630f26">m_spacing</a></td></tr>
<tr class="separator:a71abe0dddad74b2ad2c0b6193e630f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181c60138d3121c252fbad82bd30f31e"><td class="memItemLeft" align="right" valign="top"><a id="a181c60138d3121c252fbad82bd30f31e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_dot_tolerance</b></td></tr>
<tr class="separator:a181c60138d3121c252fbad82bd30f31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fdcba84116da9ac3742a9c7af54bce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a41fdcba84116da9ac3742a9c7af54bce">m_edges</a></td></tr>
<tr class="separator:a41fdcba84116da9ac3742a9c7af54bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438ad0d2d1d852b24340844efcde1a95"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmds_1_1_point_connection_builder.html#a438ad0d2d1d852b24340844efcde1a95">m_hc_mapping</a></td></tr>
<tr class="separator:a438ad0d2d1d852b24340844efcde1a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3fa500cc551f82721e6f6f9f853cd2"><td class="memItemLeft" align="right" valign="top"><a id="afe3fa500cc551f82721e6f6f9f853cd2"></a>
std::map&lt; int, <a class="el" href="classgmds_1_1_node.html">gmds::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_node_mapping</b></td></tr>
<tr class="separator:afe3fa500cc551f82721e6f6f9f853cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea813482b9ac60eaf432fadd0b4c3916"><td class="memItemLeft" align="right" valign="top"><a id="aea813482b9ac60eaf432fadd0b4c3916"></a>
std::map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_filter</b></td></tr>
<tr class="separator:aea813482b9ac60eaf432fadd0b4c3916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f34448ac600302171b37fa976c9c18"><td class="memItemLeft" align="right" valign="top"><a id="af8f34448ac600302171b37fa976c9c18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_with_debug_info</b></td></tr>
<tr class="separator:af8f34448ac600302171b37fa976c9c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333eeb59081a07182e08300f8e67de1"><td class="memItemLeft" align="right" valign="top"><a id="a0333eeb59081a07182e08300f8e67de1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_output_dir</b></td></tr>
<tr class="separator:a0333eeb59081a07182e08300f8e67de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_this.html">This</a> class provides an algorithm to connect a set of points that are defined on tetrahedral mesh where a frame field lives on. <a class="el" href="class_a.html">A</a> frame is defined for each point to connect. The output is a set of "connection" information indicating for each frame field direction where a point is connected to. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a47c383c790b65e001f98f2a1bc97d8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c383c790b65e001f98f2a1bc97d8eb">&#9670;&nbsp;</a></span>PointConnectionBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PointConnectionBuilder::PointConnectionBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> *&#160;</td>
          <td class="paramname"><em>AMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>APnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classgmds_1_1math_1_1_chart.html">gmds::math::Chart</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ACharts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structgmds_1_1_cell_1_1_data.html">gmds::Cell::Data</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ATypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>AClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ACurv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ASurf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ANormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AMesh</td><td>background tetrahedral mesh <code>APnts</code> was built from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">APnts</td><td>the points we build the hex-dom mesh from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ACharts</td><td>the charts associated to each point in <code>APnts</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATypes</td><td>a flag indicating if the corresponding point was extracted from a stable tet (0), a PGP sing tet (1) or a FF sing tet(2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AClass</td><td>a flag indicating if the corresponding point is classified onto a point (0), a curve (1), a surf(2) or a volume (3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ACurv</td><td>a flag indicating the curve number it is classified with 0 value if it is in the volume, on a surface or a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ASurf</td><td>a flag indicating the surface number it is classified with 0 value if it is in the volume, on a curve or a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ANormal</td><td>normal for each boundary node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2d7eb67183295eb81d3846c033ccc374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7eb67183295eb81d3846c033ccc374">&#9670;&nbsp;</a></span>addCorner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::addCorner </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AV2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AIndex3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>AV3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a corner data to the point with index <code>AIndex</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AIndex</td><td>the point index we add a corner to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AIndex1</td><td>the point index we execute to in direction 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AV1</td><td>the vector in direction 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AIndex2</td><td>the point index we execute to in direction 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AV2</td><td>the vector in direction 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AIndex3</td><td>the point index we execute to in direction 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AV3</td><td>the vector in direction 3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a543a7fbd297314c7463917ea9bbad919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543a7fbd297314c7463917ea9bbad919">&#9670;&nbsp;</a></span>buildCornersAsSolidAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildCornersAsSolidAngles </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build all the corners associated to <code>AOrigin</code> by considering existing edges <code>AEdges</code>. <a class="el" href="class_this.html">This</a> construction is based on geom. criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AOrigin</td><td>origin point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AEdges</td><td>existing edges connected to <code>AOrigin</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c3545fba16fad4af95e44b0425066c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3545fba16fad4af95e44b0425066c5">&#9670;&nbsp;</a></span>buildEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AInEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AOutEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Correct oriented edges to get a onsistent structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AInEdges</td><td>the list of oriented edges that we start from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOutEdges</td><td>the list of oriented edges that will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c27d9a5f8682db0afbc032cf087dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c27d9a5f8682db0afbc032cf087dbc7">&#9670;&nbsp;</a></span>buildOrientedEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildOrientedEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AEdges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build oriented edges from each point to its neighbor points in a local point of view. <code>AEdges</code>[i] contains all the oriented edges coming from point i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">AEdges</td><td>the list of oriented edges that will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad641888e3b7f0e995c06ef591e72581a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad641888e3b7f0e995c06ef591e72581a">&#9670;&nbsp;</a></span>buildOrientedEdgesInVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildOrientedEdgesInVolume </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>APntID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a>&#160;</td>
          <td class="paramname"><em>AVec</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a>&#160;</td>
          <td class="paramname"><em>APnt</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndex</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>AFound</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build oriented edges for the point <code>APntId</code> which is located into the volume. The input point is necessary REGULAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APntID</td><td>index of the point we work on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AVec</td><td>the [3][2] vectors of the frame in point APntID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">APnt</td><td>the [3][2] potential points location found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AIndex</td><td>the [3][2] potential point index found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AFound</td><td>the [3][2] Indicate if a candidate is found or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3474dbc2ec9c74d6fac66d40055f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3474dbc2ec9c74d6fac66d40055f19">&#9670;&nbsp;</a></span>buildOrientedEdgesOnCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildOrientedEdgesOnCurve </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>APntID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a>&#160;</td>
          <td class="paramname"><em>AVec</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a>&#160;</td>
          <td class="paramname"><em>APnt</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndex</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>AFound</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build oriented edges for the point <code>APntId</code> which is located on a curve. The input point is necessary REGULAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APntID</td><td>index of the point we work on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AVec</td><td>the [3][2] vectors of the frame in point APntID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">APnt</td><td>the [3][2] potential points location found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AIndex</td><td>the [3][2] potential point index found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AFound</td><td>the [3][2] Indicate if a candidate is found or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb03c4006fb36ef8db7d458a6ceea918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb03c4006fb36ef8db7d458a6ceea918">&#9670;&nbsp;</a></span>buildOrientedEdgesOnSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::buildOrientedEdgesOnSurface </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>APntID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a>&#160;</td>
          <td class="paramname"><em>AVec</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a>&#160;</td>
          <td class="paramname"><em>APnt</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndex</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>AFound</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build oriented edges for the point <code>APntId</code> which is located onto a surface. The input point is necessary REGULAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APntID</td><td>index of the point we work on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AVec</td><td>the [3][2] vectors of the frame in point APntID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">APnt</td><td>the [3][2] potential points location found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AIndex</td><td>the [3][2] potential point index found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AFound</td><td>the [3][2] Indicate if a candidate is found or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a129088b60882358b66bcc568484729df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129088b60882358b66bcc568484729df">&#9670;&nbsp;</a></span>computeMeshAssociation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::computeMeshAssociation </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the mesh association for point AID. <a class="el" href="class_this.html">This</a> computation is performed knowing how the point is classified (0,1,2 or 3) and the id of the curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AID</td><td>point id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a845626ef9aed530e4a6ee815708bd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845626ef9aed530e4a6ee815708bd5e6">&#9670;&nbsp;</a></span>filterPointsForBuildingOrientedEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PointConnectionBuilder::filterPointsForBuildingOrientedEdge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>AID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ADot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ADist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select among different point which is the bes aligned and/or at a good distance to build an oriented edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AID</td><td>the candidate point we work </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ADot</td><td>the dot product of the ref pnt and the candidate pnt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ADist</td><td>the distance between the ref pnt and the candidate pnt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the "best" candidate </dd></dl>

</div>
</div>
<a id="a571643627eb6fcc72ac3ad961f29c42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571643627eb6fcc72ac3ad961f29c42e">&#9670;&nbsp;</a></span>findCommmonLastCorner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PointConnectionBuilder::findCommmonLastCorner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>ACorner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>ACorner2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>ACorner3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>ACornerOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starting from three corner points, it returns the free corner of the point that apperas in all of them and which is pointed to all of their origins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ACorner1</td><td>first corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ACorner2</td><td>second corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ACorner3</td><td>third corner </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ACornerOut</td><td>resulting corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we find the out corner, false otherwise </dd></dl>

</div>
</div>
<a id="a44cedaf441016cb1d325a7146809748a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cedaf441016cb1d325a7146809748a">&#9670;&nbsp;</a></span>findCommonPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; PointConnectionBuilder::findCommonPoints </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AJ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find among the free corners of <code>AI</code> and <code>AJ</code> an end point which is different of <code>AFrom</code> but both in a free corner of <code>AI</code> and <code>AJ</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AFrom</td><td>point that must be appeared in <code>AI</code> and <code>AJ</code> corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td>an end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AJ</td><td>another end point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of common points </dd></dl>

</div>
</div>
<a id="a095642ed1f38d55f861e6c5fd09162ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095642ed1f38d55f861e6c5fd09162ba">&#9670;&nbsp;</a></span>findFreeCorners() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PointConnectionBuilder::findFreeCorners </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find among the corners in <code>AIn</code> those having <code>AFrom</code> as an adjacent point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AIn</td><td>the set of corners to be parsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AFrom</td><td>the point they must match </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOut</td><td>corners of <code>AIn</code> having <code>AFrom</code> as end point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of found compatible corners </dd></dl>

</div>
</div>
<a id="a57bc68481dc20f70a0abc35b8659a112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc68481dc20f70a0abc35b8659a112">&#9670;&nbsp;</a></span>findFreeCorners() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">PointConnectionBuilder::HexCorner</a> &gt; PointConnectionBuilder::findFreeCorners </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>AOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AJ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the free corners of <code>AOrigin</code> with <code>AI</code> and <code>AI</code> as end points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AOrigin</td><td>corner origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td>an end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AJ</td><td>another end point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>free corners of <code>AOrigin</code> with <code>AI</code> and <code>AI</code> as end points </dd></dl>

</div>
</div>
<a id="a91538713117f4480342ad19172557c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91538713117f4480342ad19172557c8f">&#9670;&nbsp;</a></span>getBoundaryEdgeContaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgmds_1_1_cell_1_1_data.html">Cell::Data</a> PointConnectionBuilder::getBoundaryEdgeContaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>ATetID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ADistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ACurvID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the edge information (dim=2, id) of the boundary edge that contains <code>APnt</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APnt</td><td>the point we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATetID</td><td>an initial tetrahedron we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ASurfID</td><td>the id of the curve <code>APnt</code> is supposed to be on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the info (1, id) that characterizes the edge containing APnt </dd></dl>

</div>
</div>
<a id="a83e32be1786994dd3733533588a586de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e32be1786994dd3733533588a586de">&#9670;&nbsp;</a></span>getBoundaryFaceContaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgmds_1_1_cell_1_1_data.html">Cell::Data</a> PointConnectionBuilder::getBoundaryFaceContaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>ATetID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ADistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ASurfID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the face information (dim=2, id) of the boundary face that contains <code>APnt</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APnt</td><td>the point we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATetID</td><td>an initial tetrahedron we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ASurfID</td><td>the id of the surface <code>APnt</code> is supposed to be on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the info (2, id) that characterizes the face containing APnt </dd></dl>

</div>
</div>
<a id="a54bf0ff05d26b04d29c7fc05f3c2be3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bf0ff05d26b04d29c7fc05f3c2be3e">&#9670;&nbsp;</a></span>getCloseRegionsFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">TCellID</a> &gt; PointConnectionBuilder::getCloseRegionsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromPnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;&#160;</td>
          <td class="paramname"><em>AFromTet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>AEpsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_this.html">This</a> function give the list of region ids such that generated points associated to those regions could be at a distance less or equal to <code>AEps</code> from <code>APnt</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AP</td><td>the point we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AT</td><td>the tetrahedron which should containt AP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AEps</td><td>the distance we look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ids of the tetrahedra that contains points at the specified distance </dd></dl>

</div>
</div>
<a id="af1b71de4fba2163e83feca68bb272e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b71de4fba2163e83feca68bb272e9b">&#9670;&nbsp;</a></span>getCorner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PointConnectionBuilder::getCorner </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>AOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looking at all the corners defined for origin point <code>AOrigin</code>, it returs the corner corresponding to (<code>AOrigin</code>, <code>AI</code>, <code>AJ</code>, <code>AK</code>) if it exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AOrigin</td><td>origin point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td>an end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AJ</td><td>another end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AK</td><td>another end point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOut</td><td>the found hex corner if it exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we find the out corner, false otherwise </dd></dl>

</div>
</div>
<a id="a41f8ab6e0ce0321f708c4a0f93b1796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8ab6e0ce0321f708c4a0f93b1796f">&#9670;&nbsp;</a></span>getEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::getEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AEdges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns edge info. Once performed the algorithm, we can acces to edges which are defined by the point index int the vector of point given when constructing *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">AEdges</td><td>built edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab28fe0fce68dc730f8657f6b0ec4f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28fe0fce68dc730f8657f6b0ec4f2b8">&#9670;&nbsp;</a></span>getFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmds_1_1_face.html">Face</a> PointConnectionBuilder::getFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_face.html">gmds::Face</a> &amp;&#160;</td>
          <td class="paramname"><em>AFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1_region.html">gmds::Region</a> &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>ANI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>ANJ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the face of <code>AR</code> sharing nodes <code>ANI</code> and <code>ANJ</code> with face <code>AFrom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AFrom</td><td>a face of <code>AR</code> whose <code>ANI</code> and <code>ANJ</code> are two nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AR</td><td>a region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ANI</td><td>a node id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ANJ</td><td>a node id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expected face </dd></dl>

</div>
</div>
<a id="a071566c6f0be30a48a14bf8148f4a681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071566c6f0be30a48a14bf8148f4a681">&#9670;&nbsp;</a></span>getHexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::getHexes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AHexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns hexa info. Once performed the algorithm, we can acces to all the hexahedral cells that can be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">AHex</td><td>built hexes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd03511e94509e9b48591b9f79c97f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd03511e94509e9b48591b9f79c97f8d">&#9670;&nbsp;</a></span>getRegionContaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgmds_1_1_cell_1_1_data.html">Cell::Data</a> PointConnectionBuilder::getRegionContaining </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>APnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>ATetID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the region information (dim=3, id) of the region that contains <code>APnt</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">APnt</td><td>the point we start from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATetID</td><td>an initial tetrahedron we start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the info (3, id) that characterizes the tet containing APnt </dd></dl>

</div>
</div>
<a id="a2eaa33f5876fd8fee5bae298e9f52206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaa33f5876fd8fee5bae298e9f52206">&#9670;&nbsp;</a></span>isCorner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PointConnectionBuilder::isCorner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a> &amp;&#160;</td>
          <td class="paramname"><em>AC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>AC</code> is a corner corresponding to (<code>AOrigin</code>, <code>AI</code>, <code>AJ</code>, <code>AK</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AC</td><td>the found hex corner if it exists </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AOrigin</td><td>origin point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td>an end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AJ</td><td>another end point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AK</td><td>another end point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if they correspond, false otherwise </dd></dl>

</div>
</div>
<a id="a9d74fd4429eeea40a67ff1de46b063e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d74fd4429eeea40a67ff1de46b063e3">&#9670;&nbsp;</a></span>isIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PointConnectionBuilder::isIn </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>AFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ATo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AEdgeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>AOutEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an oriented edge going from <code>AFrom</code> to <code>ATo</code> exists in <code>AEdgeSet</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AFrom</td><td><a class="el" href="class_a.html">A</a> first point index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ATo</td><td><a class="el" href="class_a.html">A</a> second point index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AEdgeSet</td><td><a class="el" href="class_a.html">A</a> set of oriented edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AOutEdge</td><td>The edge from <code>AFrom</code> to <code>ATo</code> if it exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an edge going from <code>AFrom</code> to <code>ATo</code> exists in <code>AEdgeSet</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="a4e9b706a15b551992d7d6345d60068aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9b706a15b551992d7d6345d60068aa">&#9670;&nbsp;</a></span>isIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmds::PointConnectionBuilder::isIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a>&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacegmds.html#ad3f2b3e0fe513d6bd7ed36626e1ef463">gmds::TCellID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>AV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>AI</code> is in <code>AV</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td>an id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AV</td><td>a vector of ids</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>AI</code> is in <code>AV</code>, false otherwise </dd></dl>

</div>
</div>
<a id="acc05a09ad448fb1f6ab31afd6c8feb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc05a09ad448fb1f6ab31afd6c8feb46">&#9670;&nbsp;</a></span>mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a>&amp; gmds::PointConnectionBuilder::mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the generated mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>the hexahedral cells we are able to generate </dd></dl>

</div>
</div>
<a id="a6af992b27f8c1d092596750db7c5dd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af992b27f8c1d092596750db7c5dd7e">&#9670;&nbsp;</a></span>setDebugInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PointConnectionBuilder::setDebugInfo </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>AWithDebug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>AOutputDir</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the debug info flag used during the algorithm execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AWithDebug</td><td>true to output debug info (log and files) </td></tr>
    <tr><td class="paramname">AOutputDir</td><td>directory where debug files should be written in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af577b501453d8f7d65ebbb7adb0e292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af577b501453d8f7d65ebbb7adb0e292f">&#9670;&nbsp;</a></span>setSpacing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmds::PointConnectionBuilder::setSpacing </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ASize</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In order to minimise some spatial research a spacing parameter is used in the code. Its setting is not obvious, so we can change it by this way for experiments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ASpacing</td><td>spacing value used in spatial search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7ef5c3c71a9edbf70d2b374558ab35b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef5c3c71a9edbf70d2b374558ab35b0">&#9670;&nbsp;</a></span>m_chart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classgmds_1_1math_1_1_chart.html">gmds::math::Chart</a>&gt; gmds::PointConnectionBuilder::m_chart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>rotation associated to each point used to build the mesh </p>

</div>
</div>
<a id="ae50ff6d084918e1e518cfa2c83b3212c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50ff6d084918e1e518cfa2c83b3212c">&#9670;&nbsp;</a></span>m_classification</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt; gmds::PointConnectionBuilder::m_classification</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>geometric classification of each point used to build the mesh </p>

</div>
</div>
<a id="a554174d798b8202f5d5ca2a09d768c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554174d798b8202f5d5ca2a09d768c62">&#9670;&nbsp;</a></span>m_curve</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt; gmds::PointConnectionBuilder::m_curve</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Curve numbering of each point used to build the mesh </p>

</div>
</div>
<a id="a41fdcba84116da9ac3742a9c7af54bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fdcba84116da9ac3742a9c7af54bce">&#9670;&nbsp;</a></span>m_edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="structgmds_1_1_point_connection_builder_1_1_oriented_edge.html">OrientedEdge</a>&gt; &gt; gmds::PointConnectionBuilder::m_edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>we store computed edges in this variable </p>

</div>
</div>
<a id="a438ad0d2d1d852b24340844efcde1a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438ad0d2d1d852b24340844efcde1a95">&#9670;&nbsp;</a></span>m_hc_mapping</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, std::vector&lt;<a class="el" href="structgmds_1_1_point_connection_builder_1_1_hex_corner.html">HexCorner</a>&gt; &gt; gmds::PointConnectionBuilder::m_hc_mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>mapping from each point to the number of hex corner it must be in </p>

</div>
</div>
<a id="a7847be1a31f69d2296592dc1b92a4c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7847be1a31f69d2296592dc1b92a4c57">&#9670;&nbsp;</a></span>m_hexes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a> gmds::PointConnectionBuilder::m_hexes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the generated hexahedral elements we wer mesh we work on </p>

</div>
</div>
<a id="a980b55c144bbe1b1908918ce4cadc79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b55c144bbe1b1908918ce4cadc79d">&#9670;&nbsp;</a></span>m_mesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmds_1_1_mesh.html">gmds::Mesh</a>* gmds::PointConnectionBuilder::m_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classgmds_1_1_mesh.html" title="this class represents meshes as general incidence graphs. It is possible to select the cells and conn...">Mesh</a> we start from </p>

</div>
</div>
<a id="a9701672bae3cbeacbdfebb7486d66e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701672bae3cbeacbdfebb7486d66e3e">&#9670;&nbsp;</a></span>m_normal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="classgmds_1_1math_1_1_vector_n_d.html">gmds::math::Vector3d</a>&gt; gmds::PointConnectionBuilder::m_normal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a normal constraint alignment for boundary nodes we work on </p>

</div>
</div>
<a id="ad3b0e2a89355449589b1b2927a3678d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0e2a89355449589b1b2927a3678d4">&#9670;&nbsp;</a></span>m_pnt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classgmds_1_1math_1_1_point.html">gmds::math::Point</a>&gt; gmds::PointConnectionBuilder::m_pnt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>points used to build the mesh </p>

</div>
</div>
<a id="a71abe0dddad74b2ad2c0b6193e630f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71abe0dddad74b2ad2c0b6193e630f26">&#9670;&nbsp;</a></span>m_spacing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double gmds::PointConnectionBuilder::m_spacing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the expected spacing between points </p>

</div>
</div>
<a id="a193a6bda568d44b4a1f45fa8236313c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193a6bda568d44b4a1f45fa8236313c1">&#9670;&nbsp;</a></span>m_surface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt; gmds::PointConnectionBuilder::m_surface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>surface numbering of each point used to build the mesh </p>

</div>
</div>
<a id="ae5e9a3fc675952236aed50ba0baeba44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e9a3fc675952236aed50ba0baeba44">&#9670;&nbsp;</a></span>m_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt; gmds::PointConnectionBuilder::m_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>type associated to each point used to build the mesh </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/gmds/gmds/frame3d/inc/gmds/frame3d/PointConnectionBuilder.h</li>
<li>/home/runner/work/gmds/gmds/frame3d/src/PointConnectionBuilder.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
